<!doctype html>
<meta charset="utf8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>ResizableArrayBuffer and GrowableSharedArrayBuffer</title>
<pre class=metadata>
  title: ResizableArrayBuffer and GrowableSharedArrayBuffer
  status: proposal
  stage: 2
  location: https://github.com/tc39/proposal-resizablearraybuffer
  copyright: false
  contributors: Shu-yu Guo
</pre>
<emu-intro id="intro">
  <h1>ResizableArrayBuffer and GrowableSharedArrayBuffer</h1>
  <p>We provide two new constructors, `ResizableArrayBuffer` and `GrowableSharedArrayBuffer`, which allow dynamically resizable array buffers. In addition, a `transfer` method is added to the existing `ArrayBuffer` prototype.</p>
</emu-intro>

<emu-clause id="sec-abstract-operations-for-arraybuffer-objects-mods">
  <h1>Modifications to Abstract Operations for ArrayBuffer Objects</h1>

  <emu-clause id="sec-allocatearraybuffer" aoid="AllocateArrayBuffer">
    <h1>AllocateArrayBuffer ( _constructor_, _byteLength_<ins>[ , _requestedMaxByteLength_ ]</ins> )</h1>
    <p>The abstract operation AllocateArrayBuffer takes arguments _constructor_<del> and</del><ins>,</ins> _byteLength_<ins>, and _requestedMaxByteLength_</ins>. It is used to create an ArrayBuffer object. It performs the following steps when called:</p>
    <emu-alg>
      1. <ins>Let _slots_ be &laquo; [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] &raquo;.</ins>
      1. <ins>If _requestedMaxByteLength_ is present, append [[ArrayBufferMaxByteLength]] to _slots_.</ins>
      1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *"%ArrayBuffer.prototype%"*, <del>&laquo; [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] &raquo;</del><ins>_slots</ins>).
      1. Let _block_ be ? CreateByteDataBlock(_byteLength_).
      1. Set _obj_.[[ArrayBufferData]] to _block_.
      1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
      1. <ins>If _requestedMaxByteLength_ is present, then</ins>
        1. <ins>Let _maxByteLength_ be an implementation-defined value that is either = _requestedMaxByteLength_ or both &ge; _requestedMaxByteLength_ and a power of 2.</ins>
        1. <ins>NOTE: Implementations may choose to round up the requested maximum byte length, for example, to be on a page boundary.</ins>
        1. <ins>If it is not possible to create a Data Block _block_ consisting of _maxByteLength_ bytes, throw a *RangeError* exception.</ins>
        1. <ins>NOTE: ResizableArrayBuffers are designed to be implementable with in-place growth. Implementations reserve the right to throw if, for example, virtual memory cannot be reserved up front.</ins>
        1. <ins>Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.</ins>
      1. Return _obj_.
    </emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-arraybufferlength" aoid="ArrayBufferByteLength">
    <h1>ArrayBufferByteLength ( _arrayBuffer_ )</h1>
    <p>The abstract operation ArrayBufferByteLength takes argument _arrayBuffer_. It performs the following steps when called:</p>
    <emu-alg>
      1. Assert: Type(_arrayBuffer_) is Object and _arrayBuffer_ has an [[ArrayBufferData]] internal slot.
      1. If IsSharedArrayBuffer(_arrayBuffer_) is *true* and _arrayBuffer_ has an [[ArrayBufferByteLengthData]] internal slot, then
        1. Let _bufferByteLengthBlock_ be _O_.[[ArrayBufferByteLengthData]].
        1. Return ‚Ñù(GetValueFromBuffer(_bufferByteLengthBlock_, 0, ~Uint64~, *true*, ~SeqCst~)).
      1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
      1. Return _arrayBuffer_.[[ArrayBufferByteLength]].
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-isresizablearraybuffer" aoid="IsResizableArrayBuffer">
    <h1>IsResizableArrayBuffer ( _arrayBuffer_ )</h1>
    <p>The abstract operation IsResizableArrayBuffer takes argument _arrayBuffer_. It performs the following steps when called:</p>
    <emu-alg>
      1. Assert: Type(_arrayBuffer_) is Object and _arrayBuffer_ has an [[ArrayBufferData]] internal slot.
      1. If _buffer_ has an [[ArrayBufferMaxByteLength]] internal slot, return *true*.
      1. Return *false*.
    </emu-alg>
  </emu-clause>
  </ins>
</emu-clause>

<ins class="block">
<emu-clause id="sec-resizablearraybuffer-objects">
  <h1>ResizableArrayBuffer Objects</h1>

  <emu-clause id="sec-resizablearraybuffer-constructor">
    <h1>The ResizableArrayBuffer Constructor</h1>
    <p>The ResizableArrayBuffer constructor:</p>
    <ul>
      <li>is <dfn>%ResizableArrayBuffer%</dfn>.</li>
      <li>is the initial value of the *"ResizableArrayBuffer"* property of the global object.</li>
      <li>creates and initializes a new ResizableArrayBuffer object when called as a constructor.</li>
      <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
      <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified ResizableArrayBuffer behaviour must include a `super` call to the ResizableArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the `ResizableArrayBuffer.prototype` built-in methods.</li>
    </ul>

    <emu-clause id="sec-resizablearraybuffer-initiallength-maxlength">
      <h1>ResizableArrayBuffer ( _initialLength_, _maxLength_ )</h1>
      <p>When the `ResizableArrayBuffer` function is called with arguments _initialLength_ and _maxLength_, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _byteLength_ be ? ToIndex(_initialLength_).
        1. Let _maxByteLength_ be ? ToIndex(_maxLength_).
        1. If _byteLength_ &gt; _maxByteLength_, throw a *RangeError* exception.
        1. Return ? AllocateArrayBuffer(NewTarget, _byteLength_, _maxByteLength_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-resizablearraybuffer-constructor">
    <h1>Properties of the ResizableArrayBuffer Constructor</h1>
    <p>The ResizableArrayBuffer constructor:</p>
    <ul>
      <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-resizablearraybuffer.prototype">
    <h1>ResizableArrayBuffer.prototype</h1>
    <p>The initial value of `ResizableArrayBuffer.prototype` is the ResizableArrayBuffer prototype object.</p>
    <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-resizablearraybuffer-prototype-object">
    <h1>Properties of the ResizableArrayBuffer Prototype Object</h1>
    <p>The <dfn>ResizableArrayBuffer prototype object</dfn>:</p>
    <ul>
      <li>is <dfn>%ResizableArrayBuffer.prototype%</dfn>.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>is an ordinary object.</li>
      <li>does not have an [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]], or [[ArrayBufferMaxByteLength]] internal slot.</li>
    </ul>

    <emu-clause id="sec-get-resizablearraybuffer.prototype.bytelength">
      <h1>get ResizableArrayBuffer.prototype.byteLength</h1>
      <p>`ResizableArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>ùîΩ</sub>.
        1. Let _length_ be ArrayBufferByteLength(_O_).
        1. Return ùîΩ(_length_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-resizablearraybuffer.prototype.constructor">
      <h1>ResizableArrayBuffer.prototype.constructor</h1>
      <p>The initial value of `ResizableArrayBuffer.prototype.constructor` is %ResizableArrayBuffer%.</p>
    </emu-clause>

    <emu-clause id="sec-get-resizablearraybuffer.prototype.maxbytelength">
      <h1>get ResizableArrayBuffer.prototype.maxByteLength</h1>
      <p>`ResizableArrayBuffer.prototype.maxByteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>ùîΩ</sub>.
        1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].
        1. Return ùîΩ(_length_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-resizablearraybuffer.prototype.resize">
      <h1>ResizableArrayBuffer.prototype.resize ( _newLength_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. Let _newByteLength_ be ? ToIntegerOrInfinity(_newLength_).
        1. Let _oldBlock_ be _O_.[[ArrayBufferData]].
        1. If _newByteLength_ &lt; 0 or _newByteLength_ &gt; _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.
        1. Let _newBlock_ be ? CreateByteDataBlock(_newByteLength_).
        1. Let _copyLength_ be min(_newByteLength_, _O_.[[ArrayBufferByteLength]]).
        1. Perform CopyDataBlockBytes(_newBlock_, 0, _oldBlock_, 0, _copyLength_).
        1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations reserve the right to implement this method as in-place growth or shrinkage.
        1. Set _O_.[[ArrayBufferByteLength]] to _newLength_.
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-resizablearraybuffer.prototype.slice">
      <h1>ResizableArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. Let _len_ be _O_.[[ArrayBufferByteLength]].
        1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
        1. If _relativeStart_ is -&infin;, let _first_ be 0.
        1. Else if _relativeStart_ &lt; 0, let _first_ be max(_len_ + _relativeStart_, 0).
        1. Else, let _first_ be min(_relativeStart_, _len_).
        1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
        1. If _relativeEnd_ is -&infin;, let _final_ be 0.
        1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
        1. Else, let _final_ be min(_relativeEnd_, _len_).
        1. Let _newLen_ be max(_final_ - _first_, 0).
        1. Let _new_ be ? Construct(%ArrayBuffer%, &laquo; ùîΩ(_newLen_) &raquo;).
        1. NOTE: This method returns a fixed ArrayBuffer.
        1. Let _fromBlock_ be _O_.[[ArrayBufferData]].
        1. Let _toBlock_ be _new_.[[ArrayBufferData]].
        1. Perform CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, _first_, _newLen_).
        1. Return _new_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-resizablearraybuffer.prototype.transfer">
      <h1>ResizableArrayBuffer.prototype.transfer ( [ _newLength_ ] )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
        1. If _newLength_ is not present, let _newByteLength_ be _O_.[[ArrayBufferByteLength]].
        1. Else, let _newByteLength_ be ? ToIntegerOrInfinity(_newLength_).
        1. Let _new_ be ? Construct(%ArrayBuffer%, &laquo; ùîΩ(_newByteLength_) &raquo;).
        1. NOTE: This method returns a fixed ArrayBuffer.
        1. Let _copyLength_ be min(_newByteLength_, _O_.[[ArrayBufferByteLength]]).
        1. Let _fromBlock_ be _O_.[[ArrayBufferData]].
        1. Let _toBlock_ be _new_.[[ArrayBufferData]].
        1. Perform CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, 0, _copyLength_).
        1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations reserve the right to implement this method as a zero-copy move or a `realloc`.
        1. Perform ! DetachArrayBuffer(_O_).
        1. Return _new_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-resizablearraybuffer.prototype-@@tostringtag">
      <h1>ResizableArrayBuffer.prototype [ @@toStringTag ]</h1>
      <p>The initial value of the @@toStringTag property is the String value *"ResizableArrayBuffer"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>
</ins>

<emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects-mods">
  <h1>Modifications to Abstract Operations for SharedArrayBuffer Objects</h1>

  <emu-clause id="sec-allocatesharedarraybuffer" aoid="AllocateSharedArrayBuffer">
    <h1>AllocateSharedArrayBuffer ( _constructor_, _byteLength_<ins>[ , _requestedMaxByteLength_ ]</ins> )</h1>
    <p>The abstract operation AllocateSharedArrayBuffer takes arguments _constructor_<del> and</del><ins>,</ins> _byteLength_<ins>, and _requestedMaxByteLength_</ins>. It is used to create a SharedArrayBuffer object. It performs the following steps when called:</p>
    <emu-alg>
      1. <ins>Let _slots_ be &laquo; [[ArrayBufferData]] &raquo;.</ins>
      1. <ins>If _requestedMaxByteLength_ is present, then:</ins>
      1. <ins>Append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to _slots_.</ins>
        1. <ins>Let _maxByteLength_ be an implementation-defined value that is either = _requestedMaxByteLength_ or both &ge; _requestedMaxByteLength_ and a power of 2.</ins>
        1. <ins>NOTE: Implementations may choose to round up the requested maximum byte length, for example, to be on a page boundary.</ins>
      1. <ins>Else, append [[ArrayBufferByteLength]] to _slots_.</ins>
      1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *"%SharedArrayBuffer.prototype%"*, <del>&laquo; [[ArrayBufferData]], [[ArrayBufferByteLength]] &raquo;</del><ins>_slots_</ins>).
      1. <ins>Assert: _byteLength_ &le; _maxByteLength_.</ins>
      1. <ins>If _maxByteLength_ is present, then let _allocLength_ be _byteLength_.</ins>
      1. <ins>Else, let _allocLength_ be _maxByteLength_</ins>
      1. Let _block_ be ? CreateSharedByteDataBlock(<del>_byteLength_</del><ins>_allocLength_</ins>).
      1. <ins>NOTE: GrowableSharedArrayBuffers must be implemented as in-place growable. Creation of a _maxByteLength_ sized Data Block is a specification mechanism. It may be implemented as committing a _byteLength_ sized buffer while reserving _maxByteLength_ in virtual memory.</ins>
      1. Set _obj_.[[ArrayBufferData]] to _block_.
      1. <ins>If _maxByteLength_ is present, then</ins>
        1. <ins>Let _byteLengthBlock_ be ? CreateSharedByteDataBlock(4).</ins>
        1. <ins>Perform SetValueInBuffer(_byteLengthBlock_, 0, ~Uint64~, ùîΩ(_byteLength_), *true*, ~SeqCst~).</ins>
        1. <ins>Set _obj_.[[ArrayBufferByteLengthData]] to _byteLengthBlock_.</ins>
        1. <ins>Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.</ins>
      1. <ins>Else,</ins>
        1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
      1. Return _obj_.
    </emu-alg>
  </emu-clause>
</emu-clause>

<ins class="block">
<emu-clause id="sec-growablesharedarraybuffer-objects">
  <h1>GrowableSharedArrayBuffer Objects</h1>

  <emu-clause id="sec-growablesharedarraybuffer-constructor">
    <h1>The GrowableSharedArrayBuffer Constructor</h1>
    <p>The GrowableSharedArrayBuffer constructor:</p>
    <ul>
      <li>is <dfn>%GrowableSharedArrayBuffer%</dfn>.</li>
      <li>is the initial value of the *"GrowableSharedArrayBuffer"* property of the global object.</li>
      <li>creates and initializes a new GrowableSharedArrayBuffer object when called as a constructor.</li>
      <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
      <li>is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified GrowableSharedArrayBuffer behaviour must include a `super` call to the GrowableSharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the `GrowableSharedArrayBuffer.prototype` built-in methods.</li>
    </ul>

    <emu-clause id="sec-growablesharedarraybuffere-initiallength-maxlength">
      <h1>GrowableSharedArrayBuffer ( _initialLength_, _maxLength_ )</h1>
      <p>When the `GrowableSharedArrayBuffer` function is called with arguments _initialLength_ and _maxLength_, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _byteLength_ be ? ToIndex(_initialLength_).
        1. Let _maxByteLength_ be ? ToIndex(_maxLength_).
        1. If _byteLength_ &gt; _maxByteLength_, throw a *RangeError* exception.
        1. Return ? AllocateSharedArrayBuffer(NewTarget, _byteLength_, _maxByteLength_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-growablesharedarraybuffer-constructor">
    <h1>Properties of the GrowableSharedArrayBuffer Constructor</h1>
    <p>The GrowableSharedArrayBuffer constructor has a [[Prototype]] internal slot whose value is %Function.prototype%.</p>
  </emu-clause>

  <emu-clause id="sec-growablesharedarraybuffer.prototype">
    <h1>GrowableSharedArrayBuffer.prototype</h1>
    <p>The initial value of `GrowableSharedArrayBuffer.prototype` is the GrowableSharedArrayBuffer prototype object.</p>
    <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-growablesharedarraybuffer-prototype-object">
    <h1>Properties of the GrowableSharedArrayBuffer Prototype Object</h1>
    <p>The <dfn>GrowableSharedArrayBuffer prototype object</dfn>:</p>
    <ul>
      <li>is <dfn>%GrowableSharedArrayBuffer.prototype%</dfn>.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>is an ordinary object.</li>
      <li>does not have an [[ArrayBufferData]], [[ArrayBufferByteLengthData]], or [[ArrayBufferMaxByteLength]] internal slot.</li>
    </ul>

    <emu-clause id="sec-get-growablesharedarraybuffer.prototype.bytelength">
      <h1>get GrowableSharedArrayBuffer.prototype.byteLength</h1>
      <p>`GrowableSharedArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. Let _length_ be ArrayBufferByteLength(_O_).
        1. Return ùîΩ(_length_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-growablesharedarraybuffer.prototype.constructor">
      <h1>GrowableSharedArrayBuffer.prototype.constructor</h1>
      <p>The initial value of `GrowableSharedArrayBuffer.prototype.constructor` is %GrowableSharedArrayBuffer%.</p>
    </emu-clause>

    <emu-clause id="sec-get-growablesharedarraybuffer.prototype.maxbytelength">
      <h1>get GrowableSharedArrayBuffer.prototype.maxByteLength</h1>
      <p>`GrowableSharedArrayBuffer.prototype.maxByteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. Return ùîΩ(_O_.[[ArrayBufferMaxByteLength]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-growablesharedarraybuffer.prototype.grow">
      <h1>GrowableSharedArrayBuffer.prototype.grow ( _newLength_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. Let _newByteLength_ to ? ToIntegerOrInfinity(_newLength_).
        1. If _newByteLength_ &ne; ArrayBufferByteLength(_O_), then
          1. Note: Resizes to the same length explicitly do nothing to avoid gratuitous synchronization.
          1. If _newByteLength_ &lt; ArrayBufferByteLength(_O_) or _newByteLength_ &gt; _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.
          1. Let _byteLengthBlock_ be _O_.[[ArrayBufferByteLengthData]].
          1. Perform SetValueInBuffer(_byteLengthBlock_, 0, ~Uint64~, ùîΩ(_newByteLength_), *true*, ~SeqCst~).
          1. TODO: Verify memory model event for the resize.
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-growablesharedarraybuffer.prototype.slice">
      <h1>GrowableSharedArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
        1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
        1. Let _len_ be ArrayBufferByteLength(_O_).
        1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
        1. If _relativeStart_ is -&infin;, let _first_ be 0.
        1. Else if _relativeStart_ &lt; 0, let _first_ be max(_len_ + _relativeStart_, 0).
        1. Else, let _first_ be min(_relativeStart_, _len_).
        1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
        1. If _relativeEnd_ is -&infin;, let _final_ be 0.
        1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
        1. Else, let _final_ be min(_relativeEnd_, _len_).
        1. Let _newLen_ be max(_final_ - _first_, 0).
        1. Let _new_ be ? Construct(%SharedArrayBuffer%, &laquo; ùîΩ(_newLen_) &raquo;).
        1. NOTE: This method returns a fixed SharedArrayBuffer.
        1. Let _fromBlock_ be _O_.[[ArrayBufferData]].
        1. Let _toBlock_ be _new_.[[ArrayBufferData]].
        1. Perform CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, _first_, _newLen_).
        1. Return _new_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-growablesharedarraybuffer.prototype.toString">
      <h1>GrowableSharedArrayBuffer.prototype [ @@toStringTag ]</h1>
      <p>The initial value of the @@toStringTag property is the String value *"GrowableSharedArrayBuffer"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>
</ins>

<emu-clause id="sec-properties-of-the-arraybuffer-prototype-object-mods">
  <h1>Modifications to Properties of the ArrayBuffer Prototype Object</h1>

  <emu-clause id="sec-get-arraybuffer.prototype.bytelength">
    <h1>get ArrayBuffer.prototype.byteLength</h1>
    <p>`ArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
      1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
      1. <ins>If IsResizableArrayBuffer(_O_) is *true*, throw a *TypeError* exception.</ins>
      1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>ùîΩ</sub>.
      1. Let _length_ be _O_.[[ArrayBufferByteLength]].
      1. Return ùîΩ(_length_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-arraybuffer.prototype.slice">
    <h1>ArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
    <p>The following steps are taken:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
      1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
      1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
      1. Let _len_ be _O_.[[ArrayBufferByteLength]].
      1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
      1. If _relativeStart_ is -&infin;, let _first_ be 0.
      1. Else if _relativeStart_ &lt; 0, let _first_ be max(_len_ + _relativeStart_, 0).
      1. Else, let _first_ be min(_relativeStart_, _len_).
      1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
      1. If _relativeEnd_ is -&infin;, let _final_ be 0.
      1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
      1. Else, let _final_ be min(_relativeEnd_, _len_).
      1. Let _newLen_ be max(_final_ - _first_, 0).
      1. Let _ctor_ be ? SpeciesConstructor(_O_, %ArrayBuffer%).
      1. Let _new_ be ? Construct(_ctor_, &laquo; ùîΩ(_newLen_) &raquo;).
      1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).
      1. If IsSharedArrayBuffer(_new_) is *true*, throw a *TypeError* exception.
      1. <ins>If IsResizableArrayBuffer(_new_) is *true*, throw a *TypeError* exception.</ins>
      1. If IsDetachedBuffer(_new_) is *true*, throw a *TypeError* exception.
      1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.
      1. If _new_.[[ArrayBufferByteLength]] &lt; _newLen_, throw a *TypeError* exception.
      1. NOTE: Side-effects of the above steps may have detached _O_.
      1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
      1. Let _fromBuf_ be _O_.[[ArrayBufferData]].
      1. Let _toBuf_ be _new_.[[ArrayBufferData]].
      1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).
      1. Return _new_.
    </emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-arraybuffer.prototype.transfer">
    <h1>ArrayBuffer.prototype.transfer ( [ _newLength_ ] )</h1>
    <p>The following steps are taken:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
      1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
      1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
      1. If _newLength_ is not present, let _newByteLength_ be _O_.[[ArrayBufferByteLength]].
      1. Else, let _newByteLength_ be ? ToIntegerOrInfinity(_newLength_).
      1. Let _ctor_ be ? SpeciesConstructor(_O_, %ArrayBuffer%).
      1. Let _new_ be ? Construct(_ctor_, &laquo; ùîΩ(_newLen_) &raquo;).
      1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).
      1. If IsSharedArrayBuffer(_new_) is *true*, throw a *TypeError* exception.
      1. If IsResizableArrayBuffer(_new_) is *true*, throw a *TypeError* exception.
      1. If IsDetachedBuffer(_new_) is *true*, throw a *TypeError* exception.
      1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.
      1. Let _copyLength_ be min(_newByteLength_, _O_.[[ArrayBufferByteLength]]).
      1. Let _fromBlock_ be _O_.[[ArrayBufferData]].
      1. Let _toBlock_ be _new_.[[ArrayBufferData]].
      1. Perform CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, 0, _copyLength_).
      1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations reserve the right to implement this method as a zero-copy move or a `realloc`.
      1. Perform ! DetachArrayBuffer(_O_).
      1. Return _new_.
    </emu-alg>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object-mods">
  <h1>Modifications to Properties of the SharedArrayBuffer Prototype Object</h1>

  <emu-clause id="sec-get-sharedarraybuffer.prototype.bytelength">
    <h1>get SharedArrayBuffer.prototype.byteLength</h1>
    <p>`SharedArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
      1. <ins>If IsResizableArrayBuffer(_O_) is *true*, throw a *TypeError* exception.</ins>
      1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
      1. Let _length_ be _O_.[[ArrayBufferByteLength]].
      1. Return ùîΩ(_length_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer.prototype.slice">
    <h1>SharedArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
    <p>The following steps are taken:</p>
    <emu-alg>
      1. Let _O_ be the *this* value.
      1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
      1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
      1. Let _len_ be _O_.[[ArrayBufferByteLength]].
      1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
      1. If _relativeStart_ is -&infin;, let _first_ be 0.
      1. Else if _relativeStart_ &lt; 0, let _first_ be max(_len_ + _relativeStart_, 0).
      1. Else, let _first_ be min(_relativeStart_, _len_).
      1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
      1. If _relativeEnd_ is -&infin;, let _final_ be 0.
      1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
      1. Else, let _final_ be min(_relativeEnd_, _len_).
      1. Let _newLen_ be max(_final_ - _first_, 0).
      1. Let _ctor_ be ? SpeciesConstructor(_O_, %SharedArrayBuffer%).
      1. Let _new_ be ? Construct(_ctor_, &laquo; ùîΩ(_newLen_) &raquo;).
      1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).
      1. If IsSharedArrayBuffer(_new_) is *false*, throw a *TypeError* exception.
      1. <ins>If IsResizableArrayBuffer(_new_) is *true*, throw a *TypeError* exception.</ins>
      1. If _new_.[[ArrayBufferData]] and _O_.[[ArrayBufferData]] are the same Shared Data Block values, throw a *TypeError* exception.
      1. If _new_.[[ArrayBufferByteLength]] &lt; _newLen_, throw a *TypeError* exception.
      1. Let _fromBuf_ be _O_.[[ArrayBufferData]].
      1. Let _toBuf_ be _new_.[[ArrayBufferData]].
      1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).
      1. Return _new_.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-integer-indexed-exotic-objects-mods">
  <h1>Modifications to Integer-Indexed Exotic Objects</h1>

  <emu-clause id="sec-integer-indexed-exotic-objects-ownpropertykeys">
    <h1>[[OwnPropertyKeys]] ( )</h1>
    <p>When the [[OwnPropertyKeys]] internal method of an Integer-Indexed exotic object _O_ is called, the following steps are taken:</p>
    <emu-alg>
      1. Let _keys_ be a new empty List.
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. <del>Let _len_ be _O_.[[ArrayLength]]</del>.
      1. <ins>Let _len_ be IntegerIndexedObjectLength(_O_).</ins>
      1. For each integer _i_ starting with 0 such that _i_ &lt; _len_, in ascending order, do
        1. Add ! ToString(_i_) as the last element of _keys_.
      1. For each own property key _P_ of _O_ such that Type(_P_) is String and _P_ is not an integer index, in ascending chronological order of property creation, do
        1. Add _P_ as the last element of _keys_.
      1. For each own property key _P_ of _O_ such that Type(_P_) is Symbol, in ascending chronological order of property creation, do
        1. Add _P_ as the last element of _keys_.
      1. Return _keys_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-isvalidintegerindex" aoid="IsValidIntegerIndex">
    <h1>IsValidIntegerIndex ( _O_, _index_ )</h1>
    <p>The abstract operation IsValidIntegerIndex takes arguments _O_ and _index_. It performs the following steps when called:</p>
    <emu-alg>
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. Assert: Type(_index_) is Number.
      1. If ! IsInteger(_index_) is *false*, return *false*.
      1. If _index_ is *-0*<sub>ùîΩ</sub>, return *false*.
      1. <ins>If CheckIntegerIndexedObjectOutOfBounds(_O_) is *true*, return *false*.</ins>
      1. If ‚Ñù(_index_) &lt; 0 or ‚Ñù(_index_) &ge; <del>_O_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_O_)</ins>, return *false*.
      1. Return *true*.
    </emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-integerindexedobjectbytelength" aoid="IntegerIndexedObjectByteLength">
    <h1>IntegerIndexedObjectByteLength ( _O_ )</h1>
    <p>The abstract operation IntegerIndexedObjectByteLength takes arguments _O_. It performs the following steps when called:</p>
    <emu-alg>
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. If CheckIntegerIndexedObjectOutOfBounds(_O_) is *true*, return 0.
      1. If _O_.[[ByteLength]] is not ~auto~, return _O_.[[ByteLength]].
      1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _O_.[[TypedArrayName]].
      1. Return IntegerIndexedObjectLength(_O_) &times; _elementSize_.
    </emu-alg>
    </emu-clause>

  <emu-clause id="sec-integerindexedobjectlength" aoid="IntegerIndexedObjectLength">
    <h1>IntegerIndexedObjectLength ( _O_ )</h1>
    <p>The abstract operation IntegerIndexedObjectLength takes arguments _O_. It performs the following steps when called:</p>
    <emu-alg>
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. If CheckIntegerIndexedObjectOutOfBounds(_O_) is *true*, return 0.
      1. If _O_.[[ArrayLength]] is not ~auto~, return _O_.[[ArrayLength]].
      1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
      1. Assert: IsResizableArrayBuffer(_buffer_) is *true*.
      1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_).
      1. Let _byteOffset_ be _O_.[[ByteOffset]].
      1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _O_.[[TypedArrayName]].
      1. Let _length_ be floor((_bufferByteLength_ - _byteOffset_) / _elementSize_).
      1. Return _length_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-checkintegerindexedobjectoutofbounds" aoid="CheckIntegerIndexedObjectOutOfBounds">
    <h1>CheckIntegerIndexedObjectOutOfBounds ( _O_ )</h1>
    <p>The abstract operation CheckIntegerIndexedObjectOutOfBounds takes arguments _O_. It checks if any part of the underlying viewed buffer is out of bounds. It performs the following steps when called:</p>
    <emu-alg>
      1. Assert: _O_ is an Integer-Indexed exotic object.
      1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
      1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_).
      1. Let _byteOffsetStart_ be _O_.[[ByteOffset]].
      1. If _O_.[[ArrayLength]] is ~auto~, then
        1. Let _byteOffsetEnd_ be _bufferByteLength_.
      1. Else,
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _O_.[[TypedArrayName]].
        1. Let _byteOffsetEnd_ be _O_.[[ArrayLength]] &times; _elementSize_.
      1. If _byteOffsetStart_ &ge; _bufferByteLength_ or _byteOffsetEnd_ &ge; _bufferByteLength_, then return *true*.
      1. Return *false*.
    </emu-alg>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-typedarray-objects-mods">
  <h1>Modifications to TypedArray Objects</h1>

  <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object-mods">
    <h1>Modifications to Properties of the %TypedArray.prototype% Object</h1>

    <emu-clause id="sec-validatetypedarray" aoid="ValidateTypedArray">
      <h1>Runtime Semantics: ValidateTypedArray ( _O_ )</h1>
      <p>The abstract operation ValidateTypedArray takes argument _O_. It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. <ins>If CheckIntegerIndexedObjectOutOfBounds(_O_) is *true*, throw a *TypeError* exception.</ins>
        1. Return _buffer_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
      <h1>get %TypedArray%.prototype.byteLength</h1>
      <p>%TypedArray%`.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_buffer_) is *true*, return *+0*<sub>ùîΩ</sub>.
        1. Let _size_ be <del>_O_.[[ByteLength]]</del><ins>IntegerIndexedObjectByteLength(_O_)</ins>.
        1. Return ùîΩ(_size_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
      <h1>get %TypedArray%.prototype.byteOffset</h1>
      <p>%TypedArray%`.prototype.byteOffset` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_buffer_) is *true*, return *+0*<sub>ùîΩ</sub>.
        1. <ins>If CheckIntegerIndexedObjectOutOfBounds(_O_) is *true*, return *+0*<sub>ùîΩ</sub>.</ins>
        1. Let _offset_ be _O_.[[ByteOffset]].
        1. Return ùîΩ(_offset_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.length">
      <h1>get %TypedArray%.prototype.length</h1>
      <p>%TypedArray%`.prototype.length` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
        1. Assert: _O_ has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_buffer_) is *true*, return *+0*<sub>ùîΩ</sub>.
        1. Let _length_ be <del>_O_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_O_)</ins>.
        1. Return ùîΩ(_length_).
      </emu-alg>
      <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-settypedarrayfromtypedarray" aoid="SetTypedArrayFromTypedArray" oldids="sec-%typedarray%.prototype.set-typedarray-offset">
      <h1>SetTypedArrayFromTypedArray ( _target_, _targetOffset_, _source_ )</h1>
      <p>The abstract operation SetTypedArrayFromTypedArray takes arguments _target_ (a TypedArray object), _targetOffset_ (a non-negative integer or +&infin;), and _source_ (a TypedArray object). It sets multiple values in _target_, starting at index _targetOffset_, reading the values from _source_. It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: _source_ is an Object that has a [[TypedArrayName]] internal slot.
        1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
        1. Let _targetLength_ be <del>_target_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_target_)</ins>.
        1. Let _srcBuffer_ be _source_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.
        1. <ins>If CheckIntegerIndexedObjectOutOfBounds(_target_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].
        1. Let _targetType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _targetName_.
        1. Let _targetElementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _targetName_.
        1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
        1. Let _srcName_ be the String value of _source_.[[TypedArrayName]].
        1. Let _srcType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _srcElementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _srcLength_ be _source_.[[ArrayLength]].
        1. Let _srcByteOffset_ be _source_.[[ByteOffset]].
        1. If _targetOffset_ is +&infin;, throw a *RangeError* exception.
        1. If _srcLength_ + _targetOffset_ &gt; _targetLength_, throw a *RangeError* exception.
        1. If _target_.[[ContentType]] &ne; _source_.[[ContentType]], throw a *TypeError* exception.
        1. If both IsSharedArrayBuffer(_srcBuffer_) and IsSharedArrayBuffer(_targetBuffer_) are *true*, then
          1. If _srcBuffer_.[[ArrayBufferData]] and _targetBuffer_.[[ArrayBufferData]] are the same Shared Data Block values, let _same_ be *true*; else let _same_ be *false*.
        1. Else, let _same_ be SameValue(_srcBuffer_, _targetBuffer_).
        1. If _same_ is *true*, then
          1. Let _srcByteLength_ be <del>_source_.[[ByteLength]]</del><ins>IntegerIndexedObjectByteLength(_source_)</ins>.
          1. Set _srcBuffer_ to ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_, %ArrayBuffer%).
          1. NOTE: %ArrayBuffer% is used to clone _srcBuffer_ because is it known to not have any observable side-effects.
          1. Let _srcByteIndex_ be 0.
        1. Else, let _srcByteIndex_ be _srcByteOffset_.
        1. Let _targetByteIndex_ be _targetOffset_ &times; _targetElementSize_ + _targetByteOffset_.
        1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ &times; _srcLength_.
        1. If _srcType_ is the same as _targetType_, then
          1. NOTE: If _srcType_ and _targetType_ are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
          1. Repeat, while _targetByteIndex_ &lt; _limit_,
            1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~Uint8~, *true*, ~Unordered~).
            1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~Uint8~, _value_, *true*, ~Unordered~).
            1. Set _srcByteIndex_ to _srcByteIndex_ + 1.
            1. Set _targetByteIndex_ to _targetByteIndex_ + 1.
        1. Else,
          1. Repeat, while _targetByteIndex_ &lt; _limit_,
            1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~Unordered~).
            1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~Unordered~).
            1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
            1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-constructors-mods">
    <h1>Modifications to the _TypedArray_ Constructors</h1>

    <emu-clause id="sec-initializetypedarrayfromtypedarray" aoid="InitializeTypedArrayFromTypedArray" oldids="sec-typedarray-typedarray">
      <h1>InitializeTypedArrayFromTypedArray ( _O_, _srcArray_ )</h1>
      <p>The abstract operation InitializeTypedArrayFromTypedArray takes arguments _O_ (a TypedArray object) and _srcArray_ (a TypedArray object). It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: _O_ is an Object that has a [[TypedArrayName]] internal slot.
        1. Assert: _srcArray_ is an Object that has a [[TypedArrayName]] internal slot.
        1. Let _srcData_ be _srcArray_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.
        1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].
        1. Let _elementType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _constructorName_.
        1. Let _elementLength_ be <del>_srcArray_.[[ArrayLength]]</del><ins>IntegerIndexedObjectLength(_srcArray_)</ins>.
        1. Let _srcName_ be the String value of _srcArray_.[[TypedArrayName]].
        1. Let _srcType_ be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _srcElementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _srcName_.
        1. Let _srcByteOffset_ be _srcArray_.[[ByteOffset]].
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _constructorName_.
        1. Let _byteLength_ be _elementSize_ &times; _elementLength_.
        1. If IsSharedArrayBuffer(_srcData_) is *false*, then
          1. Let _bufferConstructor_ be ? SpeciesConstructor(_srcData_, %ArrayBuffer%).
        1. Else,
          1. Let _bufferConstructor_ be %ArrayBuffer%.
        1. If _elementType_ is the same as _srcType_, then
          1. Let _data_ be ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_, _bufferConstructor_).
        1. Else,
          1. Let _data_ be ? AllocateArrayBuffer(_bufferConstructor_, _byteLength_).
          1. If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.
          1. <ins>If CheckIntegerIndexedObjectOutOfBounds(_srcArray_) is *true*, throw a *TypeError* exception.</ins>
          1. If _srcArray_.[[ContentType]] &ne; _O_.[[ContentType]], throw a *TypeError* exception.
          1. Let _srcByteIndex_ be _srcByteOffset_.
          1. Let _targetByteIndex_ be 0.
          1. Let _count_ be _elementLength_.
          1. Repeat, while _count_ &gt; 0,
            1. Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~Unordered~).
            1. Perform SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~Unordered~).
            1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
            1. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.
            1. Set _count_ to _count_ - 1.
        1. Set _O_.[[ViewedArrayBuffer]] to _data_.
        1. Set _O_.[[ByteLength]] to _byteLength_.
        1. Set _O_.[[ByteOffset]] to 0.
        1. Set _O_.[[ArrayLength]] to _elementLength_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializetypedarrayfromarraybuffer" aoid="InitializeTypedArrayFromArrayBuffer" oldids="sec-typedarray-buffer-byteoffset-length">
      <h1>InitializeTypedArrayFromArrayBuffer ( _O_, _buffer_, _byteOffset_, _length_ )</h1>
      <p>The abstract operation InitializeTypedArrayFromArrayBuffer takes arguments _O_ (a TypedArray object), _buffer_ (an ArrayBuffer object), _byteOffset_ (an ECMAScript language value), and _length_ (an ECMAScript language value). It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: _O_ is an Object that has a [[TypedArrayName]] internal slot.
        1. Assert: _buffer_ is an Object that has an [[ArrayBufferData]] internal slot.
        1. Let _constructorName_ be the String value of _O_.[[TypedArrayName]].
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _constructorName_.
        1. Let _offset_ be ? ToIndex(_byteOffset_).
        1. If _offset_ modulo _elementSize_ &ne; 0, throw a *RangeError* exception
        1. <ins>Let _bufferIsResizable_ be IsResizableArrayBuffer(_buffer_).</ins>.
        1. If _length_ is not *undefined*, then
          1. Let _newLength_ be ? ToIndex(_length_).
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. Let _bufferByteLength_ be <del>_buffer_.[[ArrayBufferByteLength]]</del><ins>ArrayBufferByteLength(_buffer_).</ins>.
        1. <ins>If _length_ is *undefined* and _bufferIsResizable_ is *true*, then</ins>
          1. <ins>If _offset_ &gt; _bufferByteLength_, throw a *RangeError* exception.</ins>
          1. <ins>Set _O_.[[ByteLength]] to ~auto~.</ins>
          1. <ins>Set _O_.[[ArrayLength]] to ~auto~.</ins>
        1. <ins>Else,</ins>
          1. If _length_ is *undefined*, then
            1. If _bufferByteLength_ modulo _elementSize_ &ne; 0, throw a *RangeError* exception.
            1. Let _newByteLength_ be _bufferByteLength_ - _offset_.
            1. If _newByteLength_ &lt; 0, throw a *RangeError* exception.
          1. Else,
            1. Let _newByteLength_ be _newLength_ &times; _elementSize_.
            1. If _offset_ + _newByteLength_ &gt; _bufferByteLength_, throw a *RangeError* exception.
          1. <del>Set _O_.[[ViewedArrayBuffer]] to _buffer_.</del>
          1. Set _O_.[[ByteLength]] to _newByteLength_.
          1. <del>Set _O_.[[ByteOffset]] to _offset_.</del>
          1. Set _O_.[[ArrayLength]] to _newByteLength_ / _elementSize_.
        1. <ins>Set _O_.[[ViewedArrayBuffer]] to _buffer_.</ins>
        1. <ins>Set _O_.[[ByteOffset]] to _offset_.</ins>
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-dataview-objects-mods">
  <h1>Modifications to DataView Objects</h1>

  <emu-clause id="sec-abstract-operations-for-dataview-objects-mods">
    <h1>Modifications to Abstract Operations For DataView Objects</h1>

    <ins class="block">
    <emu-clause id="sec-getviewbytelength" aoid="GetViewByteLength">
      <h1>GetViewByteLength ( _view_ )</h1>
      <p>The abstract operation GetViewByteLength takes argument _view_. It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
        1. If _view_.[[ByteLength]] is not ~auto~, then return _view_.[[ByteLength]].
        1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
        1. Return ArrayBufferByteLength(_buffer_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-checkviewoutofbounds" aoid="CheckViewOutOfBounds">
      <h1>CheckViewOutOfBounds ( _view_ )</h1>
      <p>The abstract operation CheckViewOutOfBounds takes argument _view_. It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
        1. Let _byteLength_ be GetViewByteLength(_view_).
        1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
        1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_).
        1. If _view_.[[ByteOffset]] + _byteLength_ &gt; _bufferByteLength_, then return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-getviewvalue" aoid="GetViewValue">
      <h1>GetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_ )</h1>
      <p>The abstract operation GetViewValue takes arguments _view_, _requestIndex_, _isLittleEndian_, and _type_. It is used by functions on DataView instances to retrieve values from the view's buffer. It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
        1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _getIndex_ be ? ToIndex(_requestIndex_).
        1. Set _isLittleEndian_ to ! ToBoolean(_isLittleEndian_).
        1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. <ins>If CheckViewOutOfBounds(_view_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _viewOffset_ be _view_.[[ByteOffset]].
        1. Let _viewSize_ be <del>_view_.[[ByteLength]]</del><ins>GetViewByteLength(_view_)</ins>.
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
        1. If _getIndex_ + _elementSize_ &gt; _viewSize_, throw a *RangeError* exception.
        1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
        1. Return GetValueFromBuffer(_buffer_, _bufferIndex_, _type_, *false*, ~Unordered~, _isLittleEndian_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setviewvalue" aoid="SetViewValue">
      <h1>SetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_, _value_ )</h1>
      <p>The abstract operation SetViewValue takes arguments _view_, _requestIndex_, _isLittleEndian_, _type_, and _value_. It is used by functions on DataView instances to store values into the view's buffer. It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
        1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _getIndex_ be ? ToIndex(_requestIndex_).
        1. If ! IsBigIntElementType(_type_) is *true*, let _numberValue_ be ? ToBigInt(_value_).
        1. Otherwise, let _numberValue_ be ? ToNumber(_value_).
        1. Set _isLittleEndian_ to ! ToBoolean(_isLittleEndian_).
        1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. <ins>If CheckViewOutOfBounds(_view_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _viewOffset_ be _view_.[[ByteOffset]].
        1. Let _viewSize_ be <del>_view_.[[ByteLength]]</del><ins>GetViewByteLength(_view_)</ins>.
        1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
        1. If _getIndex_ + _elementSize_ &gt; _viewSize_, throw a *RangeError* exception.
        1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
        1. Return SetValueInBuffer(_buffer_, _bufferIndex_, _type_, _numberValue_, *false*, ~Unordered~, _isLittleEndian_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-constructor-mods">
    <h1>Modifications to the DataView Constructor</h1>

    <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
      <h1>DataView ( _buffer_ [ , _byteOffset_ [ , _byteLength_ ] ] )</h1>
      <p>When the `DataView` function is called with at least one argument _buffer_, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Perform ? RequireInternalSlot(_buffer_, [[ArrayBufferData]]).
        1. Let _offset_ be ? ToIndex(_byteOffset_).
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. Let _bufferByteLength_ be <del>_buffer_.[[ArrayBufferByteLength]]</del><ins>ArrayBufferByteLength(_buffer_).</ins>.
        1. If _offset_ &gt; _bufferByteLength_, throw a *RangeError* exception.
        1. <ins>Let _bufferIsResizable_ be IsResizableArrayBuffer(_buffer_).</ins>
        1. <ins>If _bufferIsResizable_ is *true* and _byteLength_ is *undefined*, then</ins>
          1. <ins>Let _viewByteLength_ be ~auto~.</ins>
        1. <del>I</del><ins>Else i</ins>f _byteLength_ is *undefined*, then
          1. Let _viewByteLength_ be _bufferByteLength_ - _offset_.
        1. Else,
          1. Let _viewByteLength_ be ? ToIndex(_byteLength_).
          1. If _offset_ + _viewByteLength_ &gt; _bufferByteLength_, throw a *RangeError* exception.
        1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%DataView.prototype%"*, &laquo; [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] &raquo;).
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.
        1. Set _O_.[[ByteLength]] to _viewByteLength_.
        1. Set _O_.[[ByteOffset]] to _offset_.
        1. Return _O_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-dataview-prototype-object-mods">
    <h1>Modifications to Properties of the DataView Prototype Object</h1>

    <emu-clause id="sec-get-dataview.prototype.bytelength">
      <h1>get DataView.prototype.byteLength</h1>
      <p>`DataView.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. <ins>If CheckViewOutOfBounds(_O_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _size_ be <del>_O_.[[ByteLength]]</del><ins>GetViewByteLength(_O_)</ins>.
        1. Return ùîΩ(_size_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-dataview.prototype.byteoffset">
      <h1>get DataView.prototype.byteOffset</h1>
      <p>`DataView.prototype.byteOffset` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _O_ be the *this* value.
        1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
        1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
        1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
        1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
        1. <ins>If CheckViewOutOfBounds(_O_) is *true*, throw a *TypeError* exception.</ins>
        1. Let _offset_ be _O_.[[ByteOffset]].
        1. Return ùîΩ(_offset_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="omitted-for-brevity">
  <h1>Mechanical Changes Omitted for Brevity</h1>
  <ul>
    <li><p>Uses of [[ArrayLength]] on Integer-Indexed exotic objects are replaced with calls to IntegerIndexedObjectLength.</p></li>
    <li><p>Uses of [[ByteLength]] on Integer-Indexed exotic objects are replaced with calls to IntegerIndexedByteLength.</p></li>
    <li><p>Uses of [[ArrayBufferByteLength]] on buffer objects that may be GrowableSharedArrayBuffers are replaced with calls to ArrayBufferByteLength.</p></li>
    <li><p>Additions of %ResizableArrayBuffer% and %GrowableSharedArrayBuffer% to the intrinsics table.</p></li>
  </ul>
</emu-clause>
