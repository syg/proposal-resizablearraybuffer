<!doctype html>
<head><meta charset="utf-8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>Resizable ArrayBuffer and growable SharedArrayBuffer</title>
<script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"intro","aoid":null,"title":"Resizable ArrayBuffer and growable SharedArrayBuffer","titleHTML":"Resizable ArrayBuffer and growable SharedArrayBuffer","number":"","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Resizable ArrayBuffer and growable SharedArrayBuffer"},{"type":"op","aoid":"AllocateArrayBuffer","refId":"sec-allocatearraybuffer","location":"","referencingIds":[],"key":"AllocateArrayBuffer"},{"type":"clause","id":"sec-allocatearraybuffer","aoid":"AllocateArrayBuffer","title":"AllocateArrayBuffer ( constructor, byteLength[ , maxByteLength ] )","titleHTML":"AllocateArrayBuffer ( <var>constructor</var>, <var>byteLength</var><ins>[ , <var>maxByteLength</var> ]</ins> )","number":"1.1.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_10","_ref_12","_ref_102"],"key":"AllocateArrayBuffer ( constructor, byteLength[ , maxByteLength ] )"},{"type":"op","aoid":"ArrayBufferByteLength","refId":"sec-arraybufferlength","location":"","referencingIds":[],"key":"ArrayBufferByteLength"},{"type":"clause","id":"sec-arraybufferlength","aoid":"ArrayBufferByteLength","title":"ArrayBufferByteLength ( arrayBuffer, order )","titleHTML":"ArrayBufferByteLength ( <var>arrayBuffer</var>, <var>order</var> )","number":"1.1.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_6","_ref_47","_ref_111","_ref_154"],"key":"ArrayBufferByteLength ( arrayBuffer, order )"},{"type":"op","aoid":"MakeIdempotentArrayBufferByteLengthGetter","refId":"sec-makeidempotentarraybufferbytelengthgetter","location":"","referencingIds":[],"key":"MakeIdempotentArrayBufferByteLengthGetter"},{"type":"clause","id":"sec-makeidempotentarraybufferbytelengthgetter","aoid":"MakeIdempotentArrayBufferByteLengthGetter","title":"MakeIdempotentArrayBufferByteLengthGetter ( order )","titleHTML":"MakeIdempotentArrayBufferByteLengthGetter ( <var>order</var> )","number":"1.1.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_49","_ref_56","_ref_64","_ref_68","_ref_72","_ref_76","_ref_79","_ref_95","_ref_119","_ref_130","_ref_143","_ref_148","_ref_150"],"key":"MakeIdempotentArrayBufferByteLengthGetter ( order )"},{"type":"op","aoid":"IsResizableArrayBuffer","refId":"sec-isresizablearraybuffer","location":"","referencingIds":[],"key":"IsResizableArrayBuffer"},{"type":"clause","id":"sec-isresizablearraybuffer","aoid":"IsResizableArrayBuffer","title":"IsResizableArrayBuffer ( arrayBuffer )","titleHTML":"IsResizableArrayBuffer ( <var>arrayBuffer</var> )","number":"1.1.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_16","_ref_18","_ref_40","_ref_43","_ref_61","_ref_108","_ref_137"],"key":"IsResizableArrayBuffer ( arrayBuffer )"},{"type":"op","aoid":"HostResizeArrayBuffer","refId":"sec-hostresizearraybuffer","location":"","referencingIds":[],"key":"HostResizeArrayBuffer"},{"type":"clause","id":"sec-hostresizearraybuffer","aoid":"HostResizeArrayBuffer","title":"HostResizeArrayBuffer ( buffer, newByteLength )","titleHTML":"HostResizeArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )","number":"1.1.5","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_22"],"key":"HostResizeArrayBuffer ( buffer, newByteLength )"},{"type":"clause","id":"sec-abstract-operations-for-arraybuffer-objects-mods","aoid":null,"title":"Modifications to Abstract Operations for ArrayBuffer Objects","titleHTML":"Modifications to Abstract Operations for ArrayBuffer Objects","number":"1.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Abstract Operations for ArrayBuffer Objects"},{"type":"clause","id":"sec-arraybuffer-length","aoid":null,"title":"ArrayBuffer ( length [ , requestedMaxByteLength ] )","titleHTML":"ArrayBuffer ( <var>length</var> [ , <var>requestedMaxByteLength</var> ] )","number":"1.2.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ArrayBuffer ( length [ , requestedMaxByteLength ] )"},{"type":"clause","id":"sec-arraybuffer-constructor","aoid":null,"title":"The ArrayBuffer Constructor","titleHTML":"The ArrayBuffer Constructor","number":"1.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_28","_ref_88","_ref_89","_ref_99","_ref_100"],"key":"The ArrayBuffer Constructor"},{"type":"clause","id":"sec-get-arraybuffer.prototype.maxbytelength","aoid":null,"title":"get ArrayBuffer.prototype.maxByteLength","titleHTML":"get ArrayBuffer.prototype.maxByteLength","number":"1.3.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get ArrayBuffer.prototype.maxByteLength"},{"type":"clause","id":"sec-get-arraybuffer.prototype.resizable","aoid":null,"title":"get ArrayBuffer.prototype.resizable","titleHTML":"get ArrayBuffer.prototype.resizable","number":"1.3.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get ArrayBuffer.prototype.resizable"},{"type":"clause","id":"sec-arraybuffer.prototype.resize","aoid":null,"title":"ArrayBuffer.prototype.resize ( newLength )","titleHTML":"ArrayBuffer.prototype.resize ( <var>newLength</var> )","number":"1.3.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ArrayBuffer.prototype.resize ( newLength )"},{"type":"clause","id":"sec-arraybuffer.prototype.transfer","aoid":null,"title":"ArrayBuffer.prototype.transfer ( [ newLength ] )","titleHTML":"ArrayBuffer.prototype.transfer ( [ <var>newLength</var> ] )","number":"1.3.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ArrayBuffer.prototype.transfer ( [ newLength ] )"},{"type":"clause","id":"sec-properties-of-the-arraybuffer-prototype-object-mods","aoid":null,"title":"Modifications to the Properties of the ArrayBuffer Prototype Object","titleHTML":"Modifications to the Properties of the ArrayBuffer Prototype Object","number":"1.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to the Properties of the ArrayBuffer Prototype Object"},{"type":"clause","id":"sec-arraybuffer-objects-mods","aoid":null,"title":"Modifications to ArrayBuffer Objects","titleHTML":"Modifications to ArrayBuffer Objects","number":"1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to ArrayBuffer Objects"},{"type":"op","aoid":"AllocateSharedArrayBuffer","refId":"sec-allocatesharedarraybuffer","location":"","referencingIds":[],"key":"AllocateSharedArrayBuffer"},{"type":"clause","id":"sec-allocatesharedarraybuffer","aoid":"AllocateSharedArrayBuffer","title":"AllocateSharedArrayBuffer ( constructor, byteLength[ , maxByteLength ] )","titleHTML":"AllocateSharedArrayBuffer ( <var>constructor</var>, <var>byteLength</var><ins>[ , <var>maxByteLength</var> ]</ins> )","number":"2.1.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_36","_ref_38"],"key":"AllocateSharedArrayBuffer ( constructor, byteLength[ , maxByteLength ] )"},{"type":"op","aoid":"HostGrowSharedArrayBuffer","refId":"sec-hostgrowsharedarraybuffer","location":"","referencingIds":[],"key":"HostGrowSharedArrayBuffer"},{"type":"clause","id":"sec-hostgrowsharedarraybuffer","aoid":"HostGrowSharedArrayBuffer","title":"HostGrowSharedArrayBuffer ( buffer, newByteLength )","titleHTML":"HostGrowSharedArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )","number":"2.1.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_46"],"key":"HostGrowSharedArrayBuffer ( buffer, newByteLength )"},{"type":"clause","id":"sec-abstract-operations-for-sharedarraybuffer-objects-mods","aoid":null,"title":"Modifications to Abstract Operations for SharedArrayBuffer Objects","titleHTML":"Modifications to Abstract Operations for SharedArrayBuffer Objects","number":"2.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Abstract Operations for SharedArrayBuffer Objects"},{"type":"clause","id":"sec-sharedarraybuffer-length","aoid":null,"title":"SharedArrayBuffer ( [ length [ , requestedMaxByteLength ] ] )","titleHTML":"SharedArrayBuffer ( [ <var>length</var> [ , <var>requestedMaxByteLength</var> ] ] )","number":"2.2.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"SharedArrayBuffer ( [ length [ , requestedMaxByteLength ] ] )"},{"type":"clause","id":"sec-sharedarraybuffer-constructor","aoid":null,"title":"The SharedArrayBuffer Constructor","titleHTML":"The SharedArrayBuffer Constructor","number":"2.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"The SharedArrayBuffer Constructor"},{"type":"clause","id":"sec-get-sharedarraybuffer.prototype.maxbytelength","aoid":null,"title":"get SharedArrayBuffer.prototype.maxByteLength","titleHTML":"get SharedArrayBuffer.prototype.maxByteLength","number":"2.3.1.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get SharedArrayBuffer.prototype.maxByteLength"},{"type":"clause","id":"sec-sharedarraybuffer.prototype.grow","aoid":null,"title":"SharedArrayBuffer.prototype.grow ( newLength )","titleHTML":"SharedArrayBuffer.prototype.grow ( <var>newLength</var> )","number":"2.3.1.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"SharedArrayBuffer.prototype.grow ( newLength )"},{"type":"clause","id":"sec-get-sharedarraybuffer.prototype.growable","aoid":null,"title":"get SharedArrayBuffer.prototype.growable","titleHTML":"get SharedArrayBuffer.prototype.growable","number":"2.3.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get SharedArrayBuffer.prototype.growable"},{"type":"clause","id":"sec-properties-of-the-sharedarraybuffer-prototype-object-mods","aoid":null,"title":"Modifications to the Properties of the SharedArrayBuffer Prototype Object","titleHTML":"Modifications to the Properties of the SharedArrayBuffer Prototype Object","number":"2.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to the Properties of the SharedArrayBuffer Prototype Object"},{"type":"clause","id":"sec-sharedarraybuffer-objects-mods","aoid":null,"title":"Modifications to SharedArrayBuffer Objects","titleHTML":"Modifications to SharedArrayBuffer Objects","number":"2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to SharedArrayBuffer Objects"},{"type":"clause","id":"sec-integer-indexed-exotic-objects-ownpropertykeys","aoid":null,"title":"[[OwnPropertyKeys]] ( )","titleHTML":"[[OwnPropertyKeys]] ( )","number":"3.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"[[OwnPropertyKeys]] ( )"},{"type":"op","aoid":"IsValidIntegerIndex","refId":"sec-isvalidintegerindex","location":"","referencingIds":[],"key":"IsValidIntegerIndex"},{"type":"clause","id":"sec-isvalidintegerindex","aoid":"IsValidIntegerIndex","title":"IsValidIntegerIndex ( O, index )","titleHTML":"IsValidIntegerIndex ( <var>O</var>, <var>index</var> )","number":"3.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"IsValidIntegerIndex ( O, index )"},{"type":"op","aoid":"IntegerIndexedObjectByteLength","refId":"sec-integerindexedobjectbytelength","location":"","referencingIds":[],"key":"IntegerIndexedObjectByteLength"},{"type":"clause","id":"sec-integerindexedobjectbytelength","aoid":"IntegerIndexedObjectByteLength","title":"IntegerIndexedObjectByteLength ( O, getBufferByteLength )","titleHTML":"IntegerIndexedObjectByteLength ( <var>O</var>, <var>getBufferByteLength</var> )","number":"3.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_69","_ref_86"],"key":"IntegerIndexedObjectByteLength ( O, getBufferByteLength )"},{"type":"op","aoid":"IntegerIndexedObjectLength","refId":"sec-integerindexedobjectlength","location":"","referencingIds":[],"key":"IntegerIndexedObjectLength"},{"type":"clause","id":"sec-integerindexedobjectlength","aoid":"IntegerIndexedObjectLength","title":"IntegerIndexedObjectLength ( O, getBufferByteLength )","titleHTML":"IntegerIndexedObjectLength ( <var>O</var>, <var>getBufferByteLength</var> )","number":"3.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_50","_ref_58","_ref_59","_ref_77","_ref_80","_ref_96","_ref_151","_ref_153"],"key":"IntegerIndexedObjectLength ( O, getBufferByteLength )"},{"type":"op","aoid":"IsIntegerIndexedObjectOutOfBounds","refId":"sec-isintegerindexedobjectoutofbounds","location":"","referencingIds":[],"key":"IsIntegerIndexedObjectOutOfBounds"},{"type":"clause","id":"sec-isintegerindexedobjectoutofbounds","aoid":"IsIntegerIndexedObjectOutOfBounds","title":"IsIntegerIndexedObjectOutOfBounds ( O, getBufferByteLength )","titleHTML":"IsIntegerIndexedObjectOutOfBounds ( <var>O</var>, <var>getBufferByteLength</var> )","number":"3.5","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_57","_ref_60","_ref_65","_ref_73","_ref_82","_ref_104"],"key":"IsIntegerIndexedObjectOutOfBounds ( O, getBufferByteLength )"},{"type":"clause","id":"sec-integer-indexed-exotic-objects-mods","aoid":null,"title":"Modifications to Integer-Indexed Exotic Objects","titleHTML":"Modifications to Integer-Indexed Exotic Objects","number":"3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Integer-Indexed Exotic Objects"},{"type":"op","aoid":"ValidateTypedArray","refId":"sec-validatetypedarray","location":"","referencingIds":[],"key":"ValidateTypedArray"},{"type":"clause","id":"sec-validatetypedarray","aoid":"ValidateTypedArray","title":"Runtime Semantics: ValidateTypedArray ( O )","titleHTML":"Runtime Semantics: ValidateTypedArray ( <var>O</var> )","number":"4.1.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Runtime Semantics: ValidateTypedArray ( O )"},{"type":"clause","id":"sec-get-%typedarray%.prototype.bytelength","aoid":null,"title":"get %TypedArray%.prototype.byteLength","titleHTML":"get %TypedArray%.prototype.byteLength","number":"4.1.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get %TypedArray%.prototype.byteLength"},{"type":"clause","id":"sec-get-%typedarray%.prototype.byteoffset","aoid":null,"title":"get %TypedArray%.prototype.byteOffset","titleHTML":"get %TypedArray%.prototype.byteOffset","number":"4.1.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get %TypedArray%.prototype.byteOffset"},{"type":"clause","id":"sec-get-%typedarray%.prototype.length","aoid":null,"title":"get %TypedArray%.prototype.length","titleHTML":"get %TypedArray%.prototype.length","number":"4.1.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get %TypedArray%.prototype.length"},{"type":"op","aoid":"SetTypedArrayFromTypedArray","refId":"sec-settypedarrayfromtypedarray","location":"","referencingIds":[],"key":"SetTypedArrayFromTypedArray"},{"type":"clause","id":"sec-settypedarrayfromtypedarray","aoid":"SetTypedArrayFromTypedArray","title":"SetTypedArrayFromTypedArray ( target, targetOffset, source )","titleHTML":"SetTypedArrayFromTypedArray ( <var>target</var>, <var>targetOffset</var>, <var>source</var> )","number":"4.1.5","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"SetTypedArrayFromTypedArray ( target, targetOffset, source )"},{"type":"clause","id":"sec-properties-of-the-%typedarrayprototype%-object-mods","aoid":null,"title":"Modifications to Properties of the %TypedArray.prototype% Object","titleHTML":"Modifications to Properties of the %TypedArray.prototype% Object","number":"4.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Properties of the %TypedArray.prototype% Object"},{"type":"op","aoid":"InitializeTypedArrayFromTypedArray","refId":"sec-initializetypedarrayfromtypedarray","location":"","referencingIds":[],"key":"InitializeTypedArrayFromTypedArray"},{"type":"clause","id":"sec-initializetypedarrayfromtypedarray","aoid":"InitializeTypedArrayFromTypedArray","title":"InitializeTypedArrayFromTypedArray ( O, srcArray )","titleHTML":"InitializeTypedArrayFromTypedArray ( <var>O</var>, <var>srcArray</var> )","number":"4.2.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"InitializeTypedArrayFromTypedArray ( O, srcArray )"},{"type":"op","aoid":"InitializeTypedArrayFromArrayBuffer","refId":"sec-initializetypedarrayfromarraybuffer","location":"","referencingIds":[],"key":"InitializeTypedArrayFromArrayBuffer"},{"type":"clause","id":"sec-initializetypedarrayfromarraybuffer","aoid":"InitializeTypedArrayFromArrayBuffer","title":"InitializeTypedArrayFromArrayBuffer ( O, buffer, byteOffset, length )","titleHTML":"InitializeTypedArrayFromArrayBuffer ( <var>O</var>, <var>buffer</var>, <var>byteOffset</var>, <var>length</var> )","number":"4.2.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"InitializeTypedArrayFromArrayBuffer ( O, buffer, byteOffset, length )"},{"type":"clause","id":"sec-typedarray-constructors-mods","aoid":null,"title":"Modifications to the TypedArray Constructors","titleHTML":"Modifications to the <var>TypedArray</var> Constructors","number":"4.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to the TypedArray Constructors"},{"type":"clause","id":"sec-typedarray-objects-mods","aoid":null,"title":"Modifications to TypedArray Objects","titleHTML":"Modifications to TypedArray Objects","number":"4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to TypedArray Objects"},{"type":"op","aoid":"GetViewByteLength","refId":"sec-getviewbytelength","location":"","referencingIds":[],"key":"GetViewByteLength"},{"type":"clause","id":"sec-getviewbytelength","aoid":"GetViewByteLength","title":"GetViewByteLength ( view, getBufferByteLength )","titleHTML":"GetViewByteLength ( <var>view</var>, <var>getBufferByteLength</var> )","number":"5.1.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_114","_ref_121","_ref_132","_ref_145"],"key":"GetViewByteLength ( view, getBufferByteLength )"},{"type":"op","aoid":"IsViewOutOfBounds","refId":"sec-isviewoutofbounds","location":"","referencingIds":[],"key":"IsViewOutOfBounds"},{"type":"clause","id":"sec-isviewoutofbounds","aoid":"IsViewOutOfBounds","title":"IsViewOutOfBounds ( view, getBufferByteLength )","titleHTML":"IsViewOutOfBounds ( <var>view</var>, <var>getBufferByteLength</var> )","number":"5.1.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":["_ref_120","_ref_131","_ref_144","_ref_149"],"key":"IsViewOutOfBounds ( view, getBufferByteLength )"},{"type":"op","aoid":"GetViewValue","refId":"sec-getviewvalue","location":"","referencingIds":[],"key":"GetViewValue"},{"type":"clause","id":"sec-getviewvalue","aoid":"GetViewValue","title":"GetViewValue ( view, requestIndex, isLittleEndian, type )","titleHTML":"GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> )","number":"5.1.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"GetViewValue ( view, requestIndex, isLittleEndian, type )"},{"type":"op","aoid":"SetViewValue","refId":"sec-setviewvalue","location":"","referencingIds":[],"key":"SetViewValue"},{"type":"clause","id":"sec-setviewvalue","aoid":"SetViewValue","title":"SetViewValue ( view, requestIndex, isLittleEndian, type, value )","titleHTML":"SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> )","number":"5.1.4","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"SetViewValue ( view, requestIndex, isLittleEndian, type, value )"},{"type":"clause","id":"sec-abstract-operations-for-dataview-objects-mods","aoid":null,"title":"Modifications to Abstract Operations For DataView Objects","titleHTML":"Modifications to Abstract Operations For DataView Objects","number":"5.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Abstract Operations For DataView Objects"},{"type":"clause","id":"sec-dataview-buffer-byteoffset-bytelength","aoid":null,"title":"DataView ( buffer [ , byteOffset [ , byteLength ] ] )","titleHTML":"DataView ( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>byteLength</var> ] ] )","number":"5.2.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"DataView ( buffer [ , byteOffset [ , byteLength ] ] )"},{"type":"clause","id":"sec-dataview-constructor-mods","aoid":null,"title":"Modifications to the DataView Constructor","titleHTML":"Modifications to the DataView Constructor","number":"5.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to the DataView Constructor"},{"type":"clause","id":"sec-get-dataview.prototype.bytelength","aoid":null,"title":"get DataView.prototype.byteLength","titleHTML":"get DataView.prototype.byteLength","number":"5.3.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get DataView.prototype.byteLength"},{"type":"clause","id":"sec-get-dataview.prototype.byteoffset","aoid":null,"title":"get DataView.prototype.byteOffset","titleHTML":"get DataView.prototype.byteOffset","number":"5.3.2","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"get DataView.prototype.byteOffset"},{"type":"clause","id":"sec-properties-of-the-dataview-prototype-object-mods","aoid":null,"title":"Modifications to Properties of the DataView Prototype Object","titleHTML":"Modifications to Properties of the DataView Prototype Object","number":"5.3","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Properties of the DataView Prototype Object"},{"type":"clause","id":"sec-dataview-objects-mods","aoid":null,"title":"Modifications to DataView Objects","titleHTML":"Modifications to DataView Objects","number":"5","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to DataView Objects"},{"type":"op","aoid":"ValidateAtomicAccess","refId":"sec-validateatomicaccess","location":"","referencingIds":[],"key":"ValidateAtomicAccess"},{"type":"clause","id":"sec-validateatomicaccess","aoid":"ValidateAtomicAccess","title":"ValidateAtomicAccess ( typedArray, requestIndex )","titleHTML":"ValidateAtomicAccess ( <var>typedArray</var>, <var>requestIndex</var> )","number":"6.1","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"ValidateAtomicAccess ( typedArray, requestIndex )"},{"type":"clause","id":"sec-abstract-operations-for-atomics-mods","aoid":null,"title":"Modifications to Abstract Operations for Atomics","titleHTML":"Modifications to Abstract Operations for Atomics","number":"6","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Modifications to Abstract Operations for Atomics"},{"type":"clause","id":"sec-maxbytelength-guidelines","aoid":null,"title":"Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines","titleHTML":"Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines","number":"7","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines"},{"type":"clause","id":"omitted-for-brevity","aoid":null,"title":"Mechanical Changes Omitted for Brevity","titleHTML":"Mechanical Changes Omitted for Brevity","number":"8","namespace":"https://github.com/tc39/proposal-resizablearraybuffer","location":"","referencingIds":[],"key":"Mechanical Changes Omitted for Brevity"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Resizable ArrayBuffer and growable SharedArrayBuffer">Resizable ArrayBuffer and growable SharedArrayBuffer</a></li><li><span class="item-toggle">◢</span><a href="#sec-arraybuffer-objects-mods" title="Modifications to ArrayBuffer Objects"><span class="secnum">1</span> Modifications to ArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-arraybuffer-objects-mods" title="Modifications to Abstract Operations for ArrayBuffer Objects"><span class="secnum">1.1</span> Modifications to Abstract Operations for ArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-allocatearraybuffer" title="AllocateArrayBuffer ( constructor, byteLength[ , maxByteLength ] )"><span class="secnum">1.1.1</span> AllocateArrayBuffer ( <var>constructor</var>, <var>byteLength</var><ins>[ , <var>maxByteLength</var> ]</ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybufferlength" title="ArrayBufferByteLength ( arrayBuffer, order )"><span class="secnum">1.1.2</span> ArrayBufferByteLength ( <var>arrayBuffer</var>, <var>order</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-makeidempotentarraybufferbytelengthgetter" title="MakeIdempotentArrayBufferByteLengthGetter ( order )"><span class="secnum">1.1.3</span> MakeIdempotentArrayBufferByteLengthGetter ( <var>order</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isresizablearraybuffer" title="IsResizableArrayBuffer ( arrayBuffer )"><span class="secnum">1.1.4</span> IsResizableArrayBuffer ( <var>arrayBuffer</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-hostresizearraybuffer" title="HostResizeArrayBuffer ( buffer, newByteLength )"><span class="secnum">1.1.5</span> HostResizeArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-arraybuffer-constructor" title="The ArrayBuffer Constructor"><span class="secnum">1.2</span> The ArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer-length" title="ArrayBuffer ( length [ , requestedMaxByteLength ] )"><span class="secnum">1.2.1</span> ArrayBuffer ( <var>length</var> [ , <var>requestedMaxByteLength</var> ] )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-arraybuffer-prototype-object-mods" title="Modifications to the Properties of the ArrayBuffer Prototype Object"><span class="secnum">1.3</span> Modifications to the Properties of the ArrayBuffer Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-arraybuffer.prototype.maxbytelength" title="get ArrayBuffer.prototype.maxByteLength"><span class="secnum">1.3.1</span> get ArrayBuffer.prototype.maxByteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-arraybuffer.prototype.resizable" title="get ArrayBuffer.prototype.resizable"><span class="secnum">1.3.2</span> get ArrayBuffer.prototype.resizable</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer.prototype.resize" title="ArrayBuffer.prototype.resize ( newLength )"><span class="secnum">1.3.3</span> ArrayBuffer.prototype.resize ( <var>newLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer.prototype.transfer" title="ArrayBuffer.prototype.transfer ( [ newLength ] )"><span class="secnum">1.3.4</span> ArrayBuffer.prototype.transfer ( [ <var>newLength</var> ] )</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-sharedarraybuffer-objects-mods" title="Modifications to SharedArrayBuffer Objects"><span class="secnum">2</span> Modifications to SharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-sharedarraybuffer-objects-mods" title="Modifications to Abstract Operations for SharedArrayBuffer Objects"><span class="secnum">2.1</span> Modifications to Abstract Operations for SharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-allocatesharedarraybuffer" title="AllocateSharedArrayBuffer ( constructor, byteLength[ , maxByteLength ] )"><span class="secnum">2.1.1</span> AllocateSharedArrayBuffer ( <var>constructor</var>, <var>byteLength</var><ins>[ , <var>maxByteLength</var> ]</ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-hostgrowsharedarraybuffer" title="HostGrowSharedArrayBuffer ( buffer, newByteLength )"><span class="secnum">2.1.2</span> HostGrowSharedArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-sharedarraybuffer-constructor" title="The SharedArrayBuffer Constructor"><span class="secnum">2.2</span> The SharedArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-sharedarraybuffer-length" title="SharedArrayBuffer ( [ length [ , requestedMaxByteLength ] ] )"><span class="secnum">2.2.1</span> SharedArrayBuffer ( [ <var>length</var> [ , <var>requestedMaxByteLength</var> ] ] )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-sharedarraybuffer-prototype-object-mods" title="Modifications to the Properties of the SharedArrayBuffer Prototype Object"><span class="secnum">2.3</span> Modifications to the Properties of the SharedArrayBuffer Prototype Object</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-get-sharedarraybuffer.prototype.growable" title="get SharedArrayBuffer.prototype.growable"><span class="secnum">2.3.1</span> get SharedArrayBuffer.prototype.growable</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-sharedarraybuffer.prototype.maxbytelength" title="get SharedArrayBuffer.prototype.maxByteLength"><span class="secnum">2.3.1.1</span> get SharedArrayBuffer.prototype.maxByteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-sharedarraybuffer.prototype.grow" title="SharedArrayBuffer.prototype.grow ( newLength )"><span class="secnum">2.3.1.2</span> SharedArrayBuffer.prototype.grow ( <var>newLength</var> )</a></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-integer-indexed-exotic-objects-mods" title="Modifications to Integer-Indexed Exotic Objects"><span class="secnum">3</span> Modifications to Integer-Indexed Exotic Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-integer-indexed-exotic-objects-ownpropertykeys" title="[[OwnPropertyKeys]] ( )"><span class="secnum">3.1</span> [[OwnPropertyKeys]] ( )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isvalidintegerindex" title="IsValidIntegerIndex ( O, index )"><span class="secnum">3.2</span> IsValidIntegerIndex ( <var>O</var>, <var>index</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-integerindexedobjectbytelength" title="IntegerIndexedObjectByteLength ( O, getBufferByteLength )"><span class="secnum">3.3</span> IntegerIndexedObjectByteLength ( <var>O</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-integerindexedobjectlength" title="IntegerIndexedObjectLength ( O, getBufferByteLength )"><span class="secnum">3.4</span> IntegerIndexedObjectLength ( <var>O</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isintegerindexedobjectoutofbounds" title="IsIntegerIndexedObjectOutOfBounds ( O, getBufferByteLength )"><span class="secnum">3.5</span> IsIntegerIndexedObjectOutOfBounds ( <var>O</var>, <var>getBufferByteLength</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-typedarray-objects-mods" title="Modifications to TypedArray Objects"><span class="secnum">4</span> Modifications to TypedArray Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-%typedarrayprototype%-object-mods" title="Modifications to Properties of the %TypedArray.prototype% Object"><span class="secnum">4.1</span> Modifications to Properties of the %TypedArray.prototype% Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-validatetypedarray" title="Runtime Semantics: ValidateTypedArray ( O )"><span class="secnum">4.1.1</span> RS: ValidateTypedArray ( <var>O</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-%typedarray%.prototype.bytelength" title="get %TypedArray%.prototype.byteLength"><span class="secnum">4.1.2</span> get %TypedArray%.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-%typedarray%.prototype.byteoffset" title="get %TypedArray%.prototype.byteOffset"><span class="secnum">4.1.3</span> get %TypedArray%.prototype.byteOffset</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-%typedarray%.prototype.length" title="get %TypedArray%.prototype.length"><span class="secnum">4.1.4</span> get %TypedArray%.prototype.length</a></li><li><span class="item-toggle-none"></span><a href="#sec-settypedarrayfromtypedarray" title="SetTypedArrayFromTypedArray ( target, targetOffset, source )"><span class="secnum">4.1.5</span> SetTypedArrayFromTypedArray ( <var>target</var>, <var>targetOffset</var>, <var>source</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-typedarray-constructors-mods" title="Modifications to the TypedArray Constructors"><span class="secnum">4.2</span> Modifications to the <var>TypedArray</var> Constructors</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-initializetypedarrayfromtypedarray" title="InitializeTypedArrayFromTypedArray ( O, srcArray )"><span class="secnum">4.2.1</span> InitializeTypedArrayFromTypedArray ( <var>O</var>, <var>srcArray</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-initializetypedarrayfromarraybuffer" title="InitializeTypedArrayFromArrayBuffer ( O, buffer, byteOffset, length )"><span class="secnum">4.2.2</span> InitializeTypedArrayFromArrayBuffer ( <var>O</var>, <var>buffer</var>, <var>byteOffset</var>, <var>length</var> )</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-dataview-objects-mods" title="Modifications to DataView Objects"><span class="secnum">5</span> Modifications to DataView Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-dataview-objects-mods" title="Modifications to Abstract Operations For DataView Objects"><span class="secnum">5.1</span> Modifications to Abstract Operations For DataView Objects</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-getviewbytelength" title="GetViewByteLength ( view, getBufferByteLength )"><span class="secnum">5.1.1</span> GetViewByteLength ( <var>view</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-isviewoutofbounds" title="IsViewOutOfBounds ( view, getBufferByteLength )"><span class="secnum">5.1.2</span> IsViewOutOfBounds ( <var>view</var>, <var>getBufferByteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-getviewvalue" title="GetViewValue ( view, requestIndex, isLittleEndian, type )"><span class="secnum">5.1.3</span> GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-setviewvalue" title="SetViewValue ( view, requestIndex, isLittleEndian, type, value )"><span class="secnum">5.1.4</span> SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-dataview-constructor-mods" title="Modifications to the DataView Constructor"><span class="secnum">5.2</span> Modifications to the DataView Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-dataview-buffer-byteoffset-bytelength" title="DataView ( buffer [ , byteOffset [ , byteLength ] ] )"><span class="secnum">5.2.1</span> DataView ( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>byteLength</var> ] ] )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-dataview-prototype-object-mods" title="Modifications to Properties of the DataView Prototype Object"><span class="secnum">5.3</span> Modifications to Properties of the DataView Prototype Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-dataview.prototype.bytelength" title="get DataView.prototype.byteLength"><span class="secnum">5.3.1</span> get DataView.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#sec-get-dataview.prototype.byteoffset" title="get DataView.prototype.byteOffset"><span class="secnum">5.3.2</span> get DataView.prototype.byteOffset</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-abstract-operations-for-atomics-mods" title="Modifications to Abstract Operations for Atomics"><span class="secnum">6</span> Modifications to Abstract Operations for Atomics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-validateatomicaccess" title="ValidateAtomicAccess ( typedArray, requestIndex )"><span class="secnum">6.1</span> ValidateAtomicAccess ( <var>typedArray</var>, <var>requestIndex</var> )</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#sec-maxbytelength-guidelines" title="Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines"><span class="secnum">7</span> Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines</a></li><li><span class="item-toggle-none"></span><a href="#omitted-for-brevity" title="Mechanical Changes Omitted for Brevity"><span class="secnum">8</span> Mechanical Changes Omitted for Brevity</a></li></ol></div></div><div id="spec-container"><h1 class="version first">Stage 2 Draft / April 20, 2021</h1>
<emu-intro id="intro">
  <h1>Resizable ArrayBuffer and growable SharedArrayBuffer</h1>
  <p>We extend the <code>ArrayBuffer</code> and <code>SharedArrayBuffer</code> constructors to take an additional maximum byte length, which would construct dynamically resizable and growable array buffers, respectively. In addition, a <code>transfer</code> method is added to the <code>ArrayBuffer</code> prototype.</p>
</emu-intro>

<emu-clause id="sec-arraybuffer-objects-mods">
  <h1><span class="secnum">1</span> Modifications to ArrayBuffer Objects</h1>

  <emu-clause id="sec-abstract-operations-for-arraybuffer-objects-mods">
    <h1><span class="secnum">1.1</span> Modifications to Abstract Operations for ArrayBuffer Objects</h1>

    <emu-clause id="sec-allocatearraybuffer" aoid="AllocateArrayBuffer">
      <h1><span class="secnum">1.1.1</span> AllocateArrayBuffer ( <var>constructor</var>, <var>byteLength</var><ins>[ , <var>maxByteLength</var> ]</ins> )</h1>
      <p>The abstract operation AllocateArrayBuffer takes arguments <var>constructor</var><del> and</del><ins>,</ins> <var>byteLength</var><ins>, and <var>maxByteLength</var></ins>. It is used to create an ArrayBuffer object. It performs the following steps when called:</p>
      <emu-alg><ol><li><ins>Let <var>slots</var> be « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] ».</ins></li><li><ins>If <var>maxByteLength</var> is present, append [[ArrayBufferMaxByteLength]] to <var>slots</var>.</ins></li><li>Let <var>obj</var> be ?&nbsp;<emu-xref aoid="OrdinaryCreateFromConstructor" id="_ref_0"><a href="https://tc39.es/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(<var>constructor</var>, <emu-val>"%ArrayBuffer.prototype%"</emu-val>, <del>« [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] »</del><ins>_slots</ins>).</li><li>Let <var>block</var> be ?&nbsp;<emu-xref aoid="CreateByteDataBlock" id="_ref_1"><a href="https://tc39.es/ecma262/#sec-createbytedatablock">CreateByteDataBlock</a></emu-xref>(<var>byteLength</var>).</li><li>Set <var>obj</var>.[[ArrayBufferData]] to <var>block</var>.</li><li>Set <var>obj</var>.[[ArrayBufferByteLength]] to <var>byteLength</var>.</li><li><ins>If <var>maxByteLength</var> is present, then</ins><ol><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>byteLength</var> ≤ <var>maxByteLength</var>.</ins></li><li><ins>If it is not possible to create a <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> <var>block</var> consisting of <var>maxByteLength</var> bytes, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li><ins>NOTE: Resizable ArrayBuffers are designed to be implementable with in-place growth. Implementations reserve the right to throw if, for example, virtual memory cannot be reserved up front.</ins></li><li><ins>Set <var>obj</var>.[[ArrayBufferMaxByteLength]] to <var>maxByteLength</var>.</ins></li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-arraybufferlength" aoid="ArrayBufferByteLength">
      <h1><span class="secnum">1.1.2</span> ArrayBufferByteLength ( <var>arrayBuffer</var>, <var>order</var> )</h1>
      <p>The abstract operation ArrayBufferByteLength takes arguments <var>arrayBuffer</var> and <var>order</var> (either <emu-const>SeqCst</emu-const> or <emu-const>Unordered</emu-const>). It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type" id="_ref_2"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arrayBuffer</var>) is Object and <var>arrayBuffer</var> has an [[ArrayBufferData]] internal slot.</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_3"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val> and <var>arrayBuffer</var> has an [[ArrayBufferByteLengthData]] internal slot, then<ol><li>Let <var>bufferByteLengthBlock</var> be <var>O</var>.[[ArrayBufferByteLengthData]].</li><li>Return <emu-xref href="#ℝ"><a href="https://tc39.es/ecma262/#ℝ">ℝ</a></emu-xref>(<emu-xref aoid="GetValueFromBuffer" id="_ref_4"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>bufferByteLengthBlock</var>, 0, <emu-const>Uint64</emu-const>, <emu-val>true</emu-val>, <var>order</var>)).</li></ol></li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="IsDetachedBuffer" id="_ref_5"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>Return <var>arrayBuffer</var>.[[ArrayBufferByteLength]].</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-makeidempotentarraybufferbytelengthgetter" aoid="MakeIdempotentArrayBufferByteLengthGetter">
      <h1><span class="secnum">1.1.3</span> MakeIdempotentArrayBufferByteLengthGetter ( <var>order</var> )</h1>
      <p>The abstract operation MakeIdempotentArrayBufferByteLengthGetter takes argument <var>order</var> (either <emu-const>SeqCst</emu-const> or <emu-const>Unordered</emu-const>). The returned Abstract Closure helps ensure that there there is a single shared memory read event of the byte length data block in the calling operation. It performs the following steps when called:</p>
      <emu-alg><ol><li>NOTE: The [[ArrayBuffer]] slot is used for editorial clarity only, that a getter should only be used with a single ArrayBuffer.</li><li>Let <var>lengthStorage</var> be { [[ArrayBuffer]]: <emu-const>empty</emu-const>, [[ByteLength]]: <emu-const>empty</emu-const> }.</li><li>Let <var>getter</var> be a new Abstract Closure with parameters (<var>buffer</var>) that captures <var>lengthStorage</var>, <var>buffer</var>, and <var>order</var> and performs the following steps when called:<ol><li>If <var>lengthStorage</var>.[[ByteLength]] is not <emu-const>empty</emu-const>, then<ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>lengthStorage</var>.[[ArrayBuffer]] is <emu-const>empty</emu-const>.</li><li>Set <var>lengthStorage</var>.[[ArrayBuffer]] to <var>buffer</var>.</li><li>Set <var>lengthStorage</var>.[[ByteLength]] to <emu-xref aoid="ArrayBufferByteLength" id="_ref_6"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>buffer</var>, <var>order</var>).</li></ol></li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="SameValue" id="_ref_7"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>lengthStorage</var>.[[ArrayBuffer]], <var>buffer</var>) is <emu-val>true</emu-val>.</li><li>Return <var>lengthStorage</var>.[[ByteLength]].</li></ol></li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-isresizablearraybuffer" aoid="IsResizableArrayBuffer">
      <h1><span class="secnum">1.1.4</span> IsResizableArrayBuffer ( <var>arrayBuffer</var> )</h1>
      <p>The abstract operation IsResizableArrayBuffer takes argument <var>arrayBuffer</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type" id="_ref_8"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arrayBuffer</var>) is Object and <var>arrayBuffer</var> has an [[ArrayBufferData]] internal slot.</li><li>If <var>buffer</var> has an [[ArrayBufferMaxByteLength]] internal slot, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-hostresizearraybuffer" aoid="HostResizeArrayBuffer">
      <h1><span class="secnum">1.1.5</span> HostResizeArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</h1>
      <p>The host-defined abstract operation HostResizeArrayBuffer takes arguments <var>buffer</var> (an ArrayBuffer object) and <var>newByteLength</var>. It gives the host an opportunity to perform implementation-defined resizing of <var>buffer</var>. If the host chooses not to handle resizing of <var>buffer</var>, it may return <emu-const>unhandled</emu-const> for the default behavior.</p>

      <p>The implementation of HostResizeArrayBuffer must conform to the following requirements:</p>
      <ul>
        <li>If the abstract operation completes normally, <var>buffer</var>.[[ArrayBufferByteLength]] is <var>newByteLength</var>.</li>
        <li>The return value is either <emu-const>handled</emu-const> or <emu-const>unhandled</emu-const>.</li>
      </ul>

      <p>The default implementation of HostResizeArrayBuffer is to return <emu-const>unhandled</emu-const>.</p>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-arraybuffer-constructor">
    <h1><span class="secnum">1.2</span> The ArrayBuffer Constructor</h1>

    <emu-clause id="sec-arraybuffer-length">
      <h1><span class="secnum">1.2.1</span> ArrayBuffer ( <var>length</var> [ , <var>requestedMaxByteLength</var> ] )</h1>
      <p>When the <code>ArrayBuffer</code> function is called with argument <var>length</var><ins> and optional argument <var>requestedMaxByteLength</var></ins>, the following steps are taken:</p>
      <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>byteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_9"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>length</var>).</li><li><ins>If <var>requestedMaxByteLength</var> is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>Return ?&nbsp;<emu-xref aoid="AllocateArrayBuffer" id="_ref_10"><a href="#sec-allocatearraybuffer">AllocateArrayBuffer</a></emu-xref>(NewTarget, <var>byteLength</var>).</ins></li></ol></li><li><ins>Let <var>maxByteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_11"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>requestedMaxByteLength</var>).</ins></li><li><ins>If <var>byteLength</var> &gt; <var>maxByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li>Return ?&nbsp;<emu-xref aoid="AllocateArrayBuffer" id="_ref_12"><a href="#sec-allocatearraybuffer">AllocateArrayBuffer</a></emu-xref>(NewTarget, <var>byteLength</var><ins>, <var>maxByteLength</var></ins>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object-mods">
    <h1><span class="secnum">1.3</span> Modifications to the Properties of the ArrayBuffer Prototype Object</h1>

    <ins class="block">
    <emu-clause id="sec-get-arraybuffer.prototype.maxbytelength">
      <h1><span class="secnum">1.3.1</span> get ArrayBuffer.prototype.maxByteLength</h1>
      <p><code>ArrayBuffer.prototype.maxByteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_13"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_14"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_15"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</li><li>If <emu-xref aoid="IsResizableArrayBuffer" id="_ref_16"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferMaxByteLength]].</li></ol></li><li>Else,<ol><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferByteLength]].</li></ol></li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-arraybuffer.prototype.resizable">
      <h1><span class="secnum">1.3.2</span> get ArrayBuffer.prototype.resizable</h1>
      <p><code>ArrayBuffer.prototype.resizable</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_17"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <emu-xref aoid="IsResizableArrayBuffer" id="_ref_18"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-arraybuffer.prototype.resize">
      <h1><span class="secnum">1.3.3</span> ArrayBuffer.prototype.resize ( <var>newLength</var> )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_19"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_20"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_21"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>newByteLength</var> be ?&nbsp;ToIntegerOrInfinity(<var>newLength</var>).</li><li>If <var>newByteLength</var> &lt; 0 or <var>newByteLength</var> &gt; <var>O</var>.[[ArrayBufferMaxByteLength]], throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>hostHandled</var> be ?&nbsp;<emu-xref aoid="HostResizeArrayBuffer" id="_ref_22"><a href="#sec-hostresizearraybuffer">HostResizeArrayBuffer</a></emu-xref>(<var>O</var>, <var>newByteLength</var>).</li><li>If <var>hostHandled</var> is <emu-const>handled</emu-const>, return <emu-val>undefined</emu-val>.</li><li>Let <var>oldBlock</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>newBlock</var> be ?&nbsp;<emu-xref aoid="CreateByteDataBlock" id="_ref_23"><a href="https://tc39.es/ecma262/#sec-createbytedatablock">CreateByteDataBlock</a></emu-xref>(<var>newByteLength</var>).</li><li>Let <var>copyLength</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>newByteLength</var>, <var>O</var>.[[ArrayBufferByteLength]]).</li><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_24"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>newBlock</var>, 0, <var>oldBlock</var>, 0, <var>copyLength</var>).</li><li>NOTE: Neither creation of the new <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> nor copying from the old <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> are observable. Implementations reserve the right to implement this method as in-place growth or shrinkage.</li><li>Set <var>O</var>.[[ArrayBufferData]] to <var>newBlock</var>.</li><li>Set <var>O</var>.[[ArrayBufferByteLength]] to <var>newLength</var>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-arraybuffer.prototype.transfer">
      <h1><span class="secnum">1.3.4</span> ArrayBuffer.prototype.transfer ( [ <var>newLength</var> ] )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_25"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_26"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>newLength</var> is not present, let <var>newByteLength</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Else, let <var>newByteLength</var> be ?&nbsp;ToIntegerOrInfinity(<var>newLength</var>).</li><li>Let <var>new</var> be ?&nbsp;<emu-xref aoid="Construct" id="_ref_27"><a href="https://tc39.es/ecma262/#sec-construct">Construct</a></emu-xref>(<emu-xref href="#sec-arraybuffer-constructor" id="_ref_28"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>, « <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>newByteLength</var>) »).</li><li>NOTE: This method returns a fixed ArrayBuffer.</li><li>Let <var>copyLength</var> be <emu-xref aoid="min"><a href="https://tc39.es/ecma262/#eqn-min">min</a></emu-xref>(<var>newByteLength</var>, <var>O</var>.[[ArrayBufferByteLength]]).</li><li>Let <var>fromBlock</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBlock</var> be <var>new</var>.[[ArrayBufferData]].</li><li>Perform <emu-xref aoid="CopyDataBlockBytes" id="_ref_29"><a href="https://tc39.es/ecma262/#sec-copydatablockbytes">CopyDataBlockBytes</a></emu-xref>(<var>toBlock</var>, 0, <var>fromBlock</var>, 0, <var>copyLength</var>).</li><li>NOTE: Neither creation of the new <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> nor copying from the old <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> are observable. Implementations reserve the right to implement this method as a zero-copy move or a <code>realloc</code>.</li><li>Perform !&nbsp;<emu-xref aoid="DetachArrayBuffer" id="_ref_30"><a href="https://tc39.es/ecma262/#sec-detacharraybuffer">DetachArrayBuffer</a></emu-xref>(<var>O</var>).</li><li>Return <var>new</var>.</li></ol></emu-alg>
    </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-sharedarraybuffer-objects-mods">
  <h1><span class="secnum">2</span> Modifications to SharedArrayBuffer Objects</h1>

  <emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects-mods">
    <h1><span class="secnum">2.1</span> Modifications to Abstract Operations for SharedArrayBuffer Objects</h1>

    <emu-clause id="sec-allocatesharedarraybuffer" aoid="AllocateSharedArrayBuffer">
      <h1><span class="secnum">2.1.1</span> AllocateSharedArrayBuffer ( <var>constructor</var>, <var>byteLength</var><ins>[ , <var>maxByteLength</var> ]</ins> )</h1>
      <p>The abstract operation AllocateSharedArrayBuffer takes arguments <var>constructor</var><del> and</del><ins>,</ins> <var>byteLength</var><ins>, and <var>maxByteLength</var></ins>. It is used to create a SharedArrayBuffer object. It performs the following steps when called:</p>
      <emu-alg><ol><li><ins>Let <var>slots</var> be « [[ArrayBufferData]] ».</ins></li><li><ins>If <var>maxByteLength</var> is present, append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to <var>slots</var>.</ins></li><li><ins>Else, append [[ArrayBufferByteLength]] to <var>slots</var>.</ins></li><li>Let <var>obj</var> be ?&nbsp;<emu-xref aoid="OrdinaryCreateFromConstructor" id="_ref_31"><a href="https://tc39.es/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(<var>constructor</var>, <emu-val>"%SharedArrayBuffer.prototype%"</emu-val>, <del>« [[ArrayBufferData]], [[ArrayBufferByteLength]] »</del><ins><var>slots</var></ins>).</li><li><ins>If <var>maxByteLength</var> is present, then let <var>allocLength</var> be <var>byteLength</var>.</ins></li><li><ins>Else, let <var>allocLength</var> be <var>maxByteLength</var></ins></li><li>Let <var>block</var> be ?&nbsp;<emu-xref aoid="CreateSharedByteDataBlock" id="_ref_32"><a href="https://tc39.es/ecma262/#sec-createsharedbytedatablock">CreateSharedByteDataBlock</a></emu-xref>(<del><var>byteLength</var></del><ins><var>allocLength</var></ins>).</li><li><ins>NOTE: Growable SharedArrayBuffers must be implemented as in-place growable. Creation of a <var>maxByteLength</var> sized <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Data Block</a></emu-xref> is a specification mechanism. It may be implemented as committing a <var>byteLength</var> sized buffer while reserving <var>maxByteLength</var> in virtual memory.</ins></li><li>Set <var>obj</var>.[[ArrayBufferData]] to <var>block</var>.</li><li><ins>If <var>maxByteLength</var> is present, then</ins><ol><li><ins><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>byteLength</var> ≤ <var>maxByteLength</var>.</ins></li><li><ins>Let <var>byteLengthBlock</var> be ?&nbsp;<emu-xref aoid="CreateSharedByteDataBlock" id="_ref_33"><a href="https://tc39.es/ecma262/#sec-createsharedbytedatablock">CreateSharedByteDataBlock</a></emu-xref>(4).</ins></li><li><ins>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_34"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>byteLengthBlock</var>, 0, <emu-const>Uint64</emu-const>, <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>byteLength</var>), <emu-val>true</emu-val>, <emu-const>SeqCst</emu-const>).</ins></li><li><ins>Set <var>obj</var>.[[ArrayBufferByteLengthData]] to <var>byteLengthBlock</var>.</ins></li><li><ins>Set <var>obj</var>.[[ArrayBufferMaxByteLength]] to <var>maxByteLength</var>.</ins></li></ol></li><li><ins>Else,</ins><ol><li>Set <var>obj</var>.[[ArrayBufferByteLength]] to <var>byteLength</var>.</li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>
    </emu-clause>

    <ins class="block">
    <emu-clause id="sec-hostgrowsharedarraybuffer" aoid="HostGrowSharedArrayBuffer">
      <h1><span class="secnum">2.1.2</span> HostGrowSharedArrayBuffer ( <var>buffer</var>, <var>newByteLength</var> )</h1>
      <p>The host-defined abstract operation HostGrowSharedArrayBuffer takes arguments <var>buffer</var> (a growable SharedArrayBuffer object) and <var>newByteLength</var>. It gives the host an opportunity to perform implementation-defined growing of <var>buffer</var>. If the host chooses not to handle resizing of <var>buffer</var>, it may return <emu-const>unhandled</emu-const> for the default behavior.</p>

      <p>The implementation of HostGrowSharedArrayBuffer must conform to the following requirements:</p>
      <ul>
         <li>If the abstract operation completes normally, <var>buffer</var>.[[ArrayBufferByteLength]] is <var>newByteLength</var>.</li>
        <li>The return value is either <emu-const>handled</emu-const> or <emu-const>unhandled</emu-const>.</li>
      </ul>

      <p>The default implementation of HostGrowSharedArrayBuffer is to return <emu-const>unhandled</emu-const>.</p>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-constructor">
    <h1><span class="secnum">2.2</span> The SharedArrayBuffer Constructor</h1>

    <emu-clause id="sec-sharedarraybuffer-length">
      <h1><span class="secnum">2.2.1</span> SharedArrayBuffer ( [ <var>length</var> [ , <var>requestedMaxByteLength</var> ] ] )</h1>
      <p>When the <code>SharedArrayBuffer</code> function is called with optional arguments <var>length</var> and <var>requestedMaxByteLength</var>, the following steps are taken:</p>
      <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>byteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_35"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>length</var>).</li><li><ins>If <var>requestedMaxByteLength</var> is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>Return ?&nbsp;<emu-xref aoid="AllocateSharedArrayBuffer" id="_ref_36"><a href="#sec-allocatesharedarraybuffer">AllocateSharedArrayBuffer</a></emu-xref>(NewTarget, <var>byteLength</var>).</ins></li></ol></li><li><ins>Let <var>maxByteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_37"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>requestedMaxByteLength</var>).</ins></li><li><ins>If <var>byteLength</var> &gt; <var>maxByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li>Return ?&nbsp;<emu-xref aoid="AllocateSharedArrayBuffer" id="_ref_38"><a href="#sec-allocatesharedarraybuffer">AllocateSharedArrayBuffer</a></emu-xref>(NewTarget, <var>byteLength</var><ins>, <var>maxByteLength</var></ins>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object-mods">
    <h1><span class="secnum">2.3</span> Modifications to the Properties of the SharedArrayBuffer Prototype Object</h1>

    <ins class="block">
    <emu-clause id="sec-get-sharedarraybuffer.prototype.growable">
    <h1><span class="secnum">2.3.1</span> get SharedArrayBuffer.prototype.growable</h1>
    <p><code>SharedArrayBuffer.prototype.growable</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
    <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_39"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <emu-xref aoid="IsResizableArrayBuffer" id="_ref_40"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>).</li></ol></emu-alg>

    <emu-clause id="sec-get-sharedarraybuffer.prototype.maxbytelength">
      <h1><span class="secnum">2.3.1.1</span> get SharedArrayBuffer.prototype.maxByteLength</h1>
      <p><code>SharedArrayBuffer.prototype.maxByteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_41"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferData]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_42"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsResizableArrayBuffer" id="_ref_43"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferMaxByteLength]].</li></ol></li><li>Else,<ol><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferByteLength]].</li></ol></li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-sharedarraybuffer.prototype.grow">
      <h1><span class="secnum">2.3.1.2</span> SharedArrayBuffer.prototype.grow ( <var>newLength</var> )</h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_44"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[ArrayBufferMaxByteLength]]).</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_45"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>newByteLength</var> to ?&nbsp;ToIntegerOrInfinity(<var>newLength</var>).</li><li>If <var>newByteLength</var> &lt; <var>currentByteLength</var> or <var>newByteLength</var> &gt; <var>O</var>.[[ArrayBufferMaxByteLength]], throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>hostHandled</var> be ?&nbsp;<emu-xref aoid="HostGrowSharedArrayBuffer" id="_ref_46"><a href="#sec-hostgrowsharedarraybuffer">HostGrowSharedArrayBuffer</a></emu-xref>(<var>O</var>, <var>newByteLength</var>).</li><li>If <var>hostHandled</var> is <emu-const>handled</emu-const>, return <emu-val>undefined</emu-val>.</li><li>Let <var>currentByteLength</var> be <emu-xref aoid="ArrayBufferByteLength" id="_ref_47"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>O</var>, <emu-const>SeqCst</emu-const>).</li><li>If <var>newByteLength</var> ≠ <var>currentByteLength</var>, then<ol><li>Note: Resizes to the same length explicitly do nothing to avoid gratuitous synchronization.</li><li>Let <var>byteLengthBlock</var> be <var>O</var>.[[ArrayBufferByteLengthData]].</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_48"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>byteLengthBlock</var>, 0, <emu-const>Uint64</emu-const>, <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>newByteLength</var>), <emu-val>true</emu-val>, <emu-const>SeqCst</emu-const>).</li></ol></li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>
    </emu-clause>
    </emu-clause></ins>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-integer-indexed-exotic-objects-mods">
  <h1><span class="secnum">3</span> Modifications to Integer-Indexed Exotic Objects</h1>

  <emu-clause id="sec-integer-indexed-exotic-objects-ownpropertykeys">
    <h1><span class="secnum">3.1</span> [[OwnPropertyKeys]] ( )</h1>
    <p>When the [[OwnPropertyKeys]] internal method of an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref> <var>O</var> is called, the following steps are taken:</p>
    <emu-alg><ol><li>Let <var>keys</var> be a new empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_49"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><del>Let <var>len</var> be <var>O</var>.[[ArrayLength]]</del>.</li><li><ins>Let <var>len</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_50"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</ins></li><li>For each <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> <var>i</var> starting with 0 such that <var>i</var> &lt; <var>len</var>, in ascending order, do<ol><li>Add !&nbsp;<emu-xref aoid="ToString" id="_ref_51"><a href="https://tc39.es/ecma262/#sec-tostring">ToString</a></emu-xref>(<var>i</var>) as the last element of <var>keys</var>.</li></ol></li><li>For each own property key <var>P</var> of <var>O</var> such that <emu-xref aoid="Type" id="_ref_52"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>P</var>) is String and <var>P</var> is not an <emu-xref href="#integer-index"><a href="https://tc39.es/ecma262/#integer-index">integer index</a></emu-xref>, in ascending chronological order of property creation, do<ol><li>Add <var>P</var> as the last element of <var>keys</var>.</li></ol></li><li>For each own property key <var>P</var> of <var>O</var> such that <emu-xref aoid="Type" id="_ref_53"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>P</var>) is Symbol, in ascending chronological order of property creation, do<ol><li>Add <var>P</var> as the last element of <var>keys</var>.</li></ol></li><li>Return <var>keys</var>.</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-isvalidintegerindex" aoid="IsValidIntegerIndex">
    <h1><span class="secnum">3.2</span> IsValidIntegerIndex ( <var>O</var>, <var>index</var> )</h1>
    <p>The abstract operation IsValidIntegerIndex takes arguments <var>O</var>, <var>getBufferByteLength</var>, and <var>index</var>. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="Type" id="_ref_54"><a href="https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>index</var>) is Number.</li><li>If !&nbsp;<emu-xref aoid="IsInteger" id="_ref_55"><a href="https://tc39.es/ecma262/#sec-isinteger">IsInteger</a></emu-xref>(<var>index</var>) is <emu-val>false</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>index</var> is <emu-val>-0</emu-val><sub>𝔽</sub>, return <emu-val>false</emu-val>.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_56"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>O</var>'s backing buffer is a growable SharedArrayBuffer.</ins></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_57"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, return <emu-val>false</emu-val>.</ins></li><li>If <emu-xref href="#ℝ"><a href="https://tc39.es/ecma262/#ℝ">ℝ</a></emu-xref>(<var>index</var>) &lt; 0 or <emu-xref href="#ℝ"><a href="https://tc39.es/ecma262/#ℝ">ℝ</a></emu-xref>(<var>index</var>) ≥ <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_58"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>, return <emu-val>false</emu-val>.</li><li>Return <emu-val>true</emu-val>.</li></ol></emu-alg>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-integerindexedobjectbytelength" aoid="IntegerIndexedObjectByteLength">
    <h1><span class="secnum">3.3</span> IntegerIndexedObjectByteLength ( <var>O</var>, <var>getBufferByteLength</var> )</h1>
    <p>The abstract operation IntegerIndexedObjectByteLength takes arguments <var>O</var> and <var>getBufferByteLength</var>. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li>Let <var>length</var> be <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_59"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>).</li><li>If <var>length</var> = 0, return 0.</li><li>If <var>O</var>.[[ByteLength]] is not <emu-const>auto</emu-const>, return <var>O</var>.[[ByteLength]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>O</var>.[[TypedArrayName]].</li><li>Return <var>length</var> × <var>elementSize</var>.</li></ol></emu-alg>
    </emu-clause>

  <emu-clause id="sec-integerindexedobjectlength" aoid="IntegerIndexedObjectLength">
    <h1><span class="secnum">3.4</span> IntegerIndexedObjectLength ( <var>O</var>, <var>getBufferByteLength</var> )</h1>
    <p>The abstract operation IntegerIndexedObjectLength takes arguments <var>O</var> and <var>getBufferByteLength</var>. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_60"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, return 0.</li><li>If <var>O</var>.[[ArrayLength]] is not <emu-const>auto</emu-const>, return <var>O</var>.[[ArrayLength]].</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>Let <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <emu-xref aoid="IsResizableArrayBuffer" id="_ref_61"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>.</li><li>Let <var>byteOffset</var> be <var>O</var>.[[ByteOffset]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>O</var>.[[TypedArrayName]].</li><li>Let <var>length</var> be <emu-xref aoid="floor"><a href="https://tc39.es/ecma262/#eqn-floor">floor</a></emu-xref>((<var>bufferByteLength</var> - <var>byteOffset</var>) / <var>elementSize</var>).</li><li>Return <var>length</var>.</li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-isintegerindexedobjectoutofbounds" aoid="IsIntegerIndexedObjectOutOfBounds">
    <h1><span class="secnum">3.5</span> IsIntegerIndexedObjectOutOfBounds ( <var>O</var>, <var>getBufferByteLength</var> )</h1>
    <p>The abstract operation IsIntegerIndexedObjectOutOfBounds takes arguments <var>O</var> and <var>getBufferByteLength</var>. It checks if any part of the underlying viewed buffer is out of bounds. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an <emu-xref href="#integer-indexed-exotic-object"><a href="https://tc39.es/ecma262/#integer-indexed-exotic-object">Integer-Indexed exotic object</a></emu-xref>.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>Let <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</li><li>Let <var>byteOffsetStart</var> be <var>O</var>.[[ByteOffset]].</li><li>If <var>O</var>.[[ArrayLength]] is <emu-const>auto</emu-const>, then<ol><li>Let <var>byteOffsetEnd</var> be <var>bufferByteLength</var>.</li></ol></li><li>Else,<ol><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>O</var>.[[TypedArrayName]].</li><li>Let <var>byteOffsetEnd</var> be <var>O</var>.[[ArrayLength]] × <var>elementSize</var>.</li></ol></li><li>If <var>byteOffsetStart</var> ≥ <var>bufferByteLength</var> or <var>byteOffsetEnd</var> ≥ <var>bufferByteLength</var>, then return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-typedarray-objects-mods">
  <h1><span class="secnum">4</span> Modifications to TypedArray Objects</h1>

  <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object-mods">
    <h1><span class="secnum">4.1</span> Modifications to Properties of the %TypedArray.prototype% Object</h1>

    <emu-clause id="sec-validatetypedarray" aoid="ValidateTypedArray">
      <h1><span class="secnum">4.1.1</span> Runtime Semantics: ValidateTypedArray ( <var>O</var> )</h1>
      <p>The abstract operation ValidateTypedArray takes argument <var>O</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_62"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_63"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_64"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_65"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Return <var>buffer</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
      <h1><span class="secnum">4.1.2</span> get %TypedArray%.prototype.byteLength</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_66"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_67"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_68"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>size</var> be <del><var>O</var>.[[ByteLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectByteLength" id="_ref_69"><a href="#sec-integerindexedobjectbytelength">IntegerIndexedObjectByteLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>size</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
      <h1><span class="secnum">4.1.3</span> get %TypedArray%.prototype.byteOffset</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.byteOffset</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_70"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_71"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_72"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_73"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</ins></li><li>Let <var>offset</var> be <var>O</var>.[[ByteOffset]].</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>offset</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-%typedarray%.prototype.length">
      <h1><span class="secnum">4.1.4</span> get %TypedArray%.prototype.length</h1>
      <p><emu-xref href="#sec-%typedarray%-intrinsic-object"><a href="https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object">%TypedArray%</a></emu-xref><code>.prototype.length</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_74"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[TypedArrayName]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_75"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, return <emu-val>+0</emu-val><sub>𝔽</sub>.</li><li>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_76"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</li><li>Let <var>length</var> be <del><var>O</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_77"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>length</var>).</li></ol></emu-alg>
      <p>This function is not generic. The <emu-val>this</emu-val> value must be an object with a [[TypedArrayName]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-settypedarrayfromtypedarray" aoid="SetTypedArrayFromTypedArray" oldids="sec-%typedarray%.prototype.set-typedarray-offset">
      <span id="sec-%typedarray%.prototype.set-typedarray-offset"></span><h1><span class="secnum">4.1.5</span> SetTypedArrayFromTypedArray ( <var>target</var>, <var>targetOffset</var>, <var>source</var> )</h1>
      <p>The abstract operation SetTypedArrayFromTypedArray takes arguments <var>target</var> (a TypedArray object), <var>targetOffset</var> (a non-negative <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">integer</a></emu-xref> or +∞), and <var>source</var> (a TypedArray object). It sets multiple values in <var>target</var>, starting at index <var>targetOffset</var>, reading the values from <var>source</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>source</var> is an Object that has a [[TypedArrayName]] internal slot.</li><li>Let <var>targetBuffer</var> be <var>target</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_78"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>targetBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getSrcBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_79"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>targetLength</var> be <del><var>target</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_80"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>target</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Let <var>srcBuffer</var> be <var>source</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_81"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_82"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>target</var>, getSrcBufferByteLength_) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>targetName</var> be the String value of <var>target</var>.[[TypedArrayName]].</li><li>Let <var>targetType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetElementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetByteOffset</var> be <var>target</var>.[[ByteOffset]].</li><li>Let <var>srcName</var> be the String value of <var>source</var>.[[TypedArrayName]].</li><li>Let <var>srcType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcElementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcLength</var> be <var>source</var>.[[ArrayLength]].</li><li>Let <var>srcByteOffset</var> be <var>source</var>.[[ByteOffset]].</li><li>If <var>targetOffset</var> is +∞, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>srcLength</var> + <var>targetOffset</var> &gt; <var>targetLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>target</var>.[[ContentType]] ≠ <var>source</var>.[[ContentType]], throw a <emu-val>TypeError</emu-val> exception.</li><li>If both <emu-xref aoid="IsSharedArrayBuffer" id="_ref_83"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>srcBuffer</var>) and <emu-xref aoid="IsSharedArrayBuffer" id="_ref_84"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>targetBuffer</var>) are <emu-val>true</emu-val>, then<ol><li>If <var>srcBuffer</var>.[[ArrayBufferData]] and <var>targetBuffer</var>.[[ArrayBufferData]] are the same <emu-xref href="#sec-data-blocks"><a href="https://tc39.es/ecma262/#sec-data-blocks">Shared Data Block</a></emu-xref> values, let <var>same</var> be <emu-val>true</emu-val>; else let <var>same</var> be <emu-val>false</emu-val>.</li></ol></li><li>Else, let <var>same</var> be <emu-xref aoid="SameValue" id="_ref_85"><a href="https://tc39.es/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcBuffer</var>, <var>targetBuffer</var>).</li><li>If <var>same</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>srcByteLength</var> be <del><var>source</var>.[[ByteLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectByteLength" id="_ref_86"><a href="#sec-integerindexedobjectbytelength">IntegerIndexedObjectByteLength</a></emu-xref>(<var>source</var>, <var>getSrcBufferByteLength</var>)</ins>.</li><li>Set <var>srcBuffer</var> to ?&nbsp;<emu-xref aoid="CloneArrayBuffer" id="_ref_87"><a href="https://tc39.es/ecma262/#sec-clonearraybuffer">CloneArrayBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteOffset</var>, <var>srcByteLength</var>, <emu-xref href="#sec-arraybuffer-constructor" id="_ref_88"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>NOTE: <emu-xref href="#sec-arraybuffer-constructor" id="_ref_89"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref> is used to clone <var>srcBuffer</var> because is it known to not have any observable side-effects.</li><li>Let <var>srcByteIndex</var> be 0.</li></ol></li><li>Else, let <var>srcByteIndex</var> be <var>srcByteOffset</var>.</li><li>Let <var>targetByteIndex</var> be <var>targetOffset</var> × <var>targetElementSize</var> + <var>targetByteOffset</var>.</li><li>Let <var>limit</var> be <var>targetByteIndex</var> + <var>targetElementSize</var> × <var>srcLength</var>.</li><li>If <var>srcType</var> is the same as <var>targetType</var>, then<ol><li>NOTE: If <var>srcType</var> and <var>targetType</var> are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.</li><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var>,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer" id="_ref_90"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <emu-const>Uint8</emu-const>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_91"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <emu-const>Uint8</emu-const>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + 1.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + 1.</li></ol></li></ol></li><li>Else,<ol><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var>,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer" id="_ref_92"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <var>srcType</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_93"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <var>targetType</var>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + <var>srcElementSize</var>.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + <var>targetElementSize</var>.</li></ol></li></ol></li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-constructors-mods">
    <h1><span class="secnum">4.2</span> Modifications to the <var>TypedArray</var> Constructors</h1>

    <emu-clause id="sec-initializetypedarrayfromtypedarray" aoid="InitializeTypedArrayFromTypedArray" oldids="sec-typedarray-typedarray">
      <span id="sec-typedarray-typedarray"></span><h1><span class="secnum">4.2.1</span> InitializeTypedArrayFromTypedArray ( <var>O</var>, <var>srcArray</var> )</h1>
      <p>The abstract operation InitializeTypedArrayFromTypedArray takes arguments <var>O</var> (a TypedArray object) and <var>srcArray</var> (a TypedArray object). It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an Object that has a [[TypedArrayName]] internal slot.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>srcArray</var> is an Object that has a [[TypedArrayName]] internal slot.</li><li>Let <var>srcData</var> be <var>srcArray</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_94"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcData</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>constructorName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>elementType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>constructorName</var>.</li><li><ins>Let <var>getSrcBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_95"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li>Let <var>elementLength</var> be <del><var>srcArray</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_96"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>srcArray</var>, <var>getSrcBufferByteLength</var>)</ins>.</li><li>Let <var>srcName</var> be the String value of <var>srcArray</var>.[[TypedArrayName]].</li><li>Let <var>srcType</var> be the Element Type value in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcElementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcByteOffset</var> be <var>srcArray</var>.[[ByteOffset]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>constructorName</var>.</li><li>Let <var>byteLength</var> be <var>elementSize</var> × <var>elementLength</var>.</li><li>If <emu-xref aoid="IsSharedArrayBuffer" id="_ref_97"><a href="https://tc39.es/ecma262/#sec-issharedarraybuffer">IsSharedArrayBuffer</a></emu-xref>(<var>srcData</var>) is <emu-val>false</emu-val>, then<ol><li>Let <var>bufferConstructor</var> be ?&nbsp;<emu-xref aoid="SpeciesConstructor" id="_ref_98"><a href="https://tc39.es/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>srcData</var>, <emu-xref href="#sec-arraybuffer-constructor" id="_ref_99"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li></ol></li><li>Else,<ol><li>Let <var>bufferConstructor</var> be <emu-xref href="#sec-arraybuffer-constructor" id="_ref_100"><a href="#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>.</li></ol></li><li>If <var>elementType</var> is the same as <var>srcType</var>, then<ol><li>Let <var>data</var> be ?&nbsp;<emu-xref aoid="CloneArrayBuffer" id="_ref_101"><a href="https://tc39.es/ecma262/#sec-clonearraybuffer">CloneArrayBuffer</a></emu-xref>(<var>srcData</var>, <var>srcByteOffset</var>, <var>byteLength</var>, <var>bufferConstructor</var>).</li></ol></li><li>Else,<ol><li>Let <var>data</var> be ?&nbsp;<emu-xref aoid="AllocateArrayBuffer" id="_ref_102"><a href="#sec-allocatearraybuffer">AllocateArrayBuffer</a></emu-xref>(<var>bufferConstructor</var>, <var>byteLength</var>).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_103"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcData</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="IsIntegerIndexedObjectOutOfBounds" id="_ref_104"><a href="#sec-isintegerindexedobjectoutofbounds">IsIntegerIndexedObjectOutOfBounds</a></emu-xref>(<var>srcArray</var>, <var>getSrcBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>If <var>srcArray</var>.[[ContentType]] ≠ <var>O</var>.[[ContentType]], throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>srcByteIndex</var> be <var>srcByteOffset</var>.</li><li>Let <var>targetByteIndex</var> be 0.</li><li>Let <var>count</var> be <var>elementLength</var>.</li><li>Repeat, while <var>count</var> &gt; 0,<ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer" id="_ref_105"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>srcData</var>, <var>srcByteIndex</var>, <var>srcType</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Perform <emu-xref aoid="SetValueInBuffer" id="_ref_106"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>data</var>, <var>targetByteIndex</var>, <var>elementType</var>, <var>value</var>, <emu-val>true</emu-val>, <emu-const>Unordered</emu-const>).</li><li>Set <var>srcByteIndex</var> to <var>srcByteIndex</var> + <var>srcElementSize</var>.</li><li>Set <var>targetByteIndex</var> to <var>targetByteIndex</var> + <var>elementSize</var>.</li><li>Set <var>count</var> to <var>count</var> - 1.</li></ol></li></ol></li><li>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>data</var>.</li><li>Set <var>O</var>.[[ByteLength]] to <var>byteLength</var>.</li><li>Set <var>O</var>.[[ByteOffset]] to 0.</li><li>Set <var>O</var>.[[ArrayLength]] to <var>elementLength</var>.</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializetypedarrayfromarraybuffer" aoid="InitializeTypedArrayFromArrayBuffer" oldids="sec-typedarray-buffer-byteoffset-length">
      <span id="sec-typedarray-buffer-byteoffset-length"></span><h1><span class="secnum">4.2.2</span> InitializeTypedArrayFromArrayBuffer ( <var>O</var>, <var>buffer</var>, <var>byteOffset</var>, <var>length</var> )</h1>
      <p>The abstract operation InitializeTypedArrayFromArrayBuffer takes arguments <var>O</var> (a TypedArray object), <var>buffer</var> (an ArrayBuffer object), <var>byteOffset</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>), and <var>length</var> (an <emu-xref href="#sec-ecmascript-language-types"><a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">ECMAScript language value</a></emu-xref>). It performs the following steps when called:</p>
      <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> is an Object that has a [[TypedArrayName]] internal slot.</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>buffer</var> is an Object that has an [[ArrayBufferData]] internal slot.</li><li>Let <var>constructorName</var> be the String value of <var>O</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>constructorName</var>.</li><li>Let <var>offset</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_107"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>byteOffset</var>).</li><li>If <var>offset</var> <emu-xref aoid="modulo"><a href="https://tc39.es/ecma262/#eqn-modulo">modulo</a></emu-xref> <var>elementSize</var> ≠ 0, throw a <emu-val>RangeError</emu-val> exception</li><li><ins>Let <var>bufferIsResizable</var> be <emu-xref aoid="IsResizableArrayBuffer" id="_ref_108"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>buffer</var>).</ins>.</li><li>If <var>length</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>newLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_109"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>length</var>).</li></ol></li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_110"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>bufferByteLength</var> be <del><var>buffer</var>.[[ArrayBufferByteLength]]</del><ins><emu-xref aoid="ArrayBufferByteLength" id="_ref_111"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>(<var>buffer</var>, <emu-const>SeqCst</emu-const>).</ins>.</li><li><ins>If <var>length</var> is <emu-val>undefined</emu-val> and <var>bufferIsResizable</var> is <emu-val>true</emu-val>, then</ins><ol><li><ins>If <var>offset</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</ins></li><li><ins>Set <var>O</var>.[[ByteLength]] to <emu-const>auto</emu-const>.</ins></li><li><ins>Set <var>O</var>.[[ArrayLength]] to <emu-const>auto</emu-const>.</ins></li></ol></li><li><ins>Else,</ins><ol><li>If <var>length</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>bufferByteLength</var> <emu-xref aoid="modulo"><a href="https://tc39.es/ecma262/#eqn-modulo">modulo</a></emu-xref> <var>elementSize</var> ≠ 0, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>newByteLength</var> be <var>bufferByteLength</var> - <var>offset</var>.</li><li>If <var>newByteLength</var> &lt; 0, throw a <emu-val>RangeError</emu-val> exception.</li></ol></li><li>Else,<ol><li>Let <var>newByteLength</var> be <var>newLength</var> × <var>elementSize</var>.</li><li>If <var>offset</var> + <var>newByteLength</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li></ol></li><li><del>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>buffer</var>.</del></li><li>Set <var>O</var>.[[ByteLength]] to <var>newByteLength</var>.</li><li><del>Set <var>O</var>.[[ByteOffset]] to <var>offset</var>.</del></li><li>Set <var>O</var>.[[ArrayLength]] to <var>newByteLength</var> / <var>elementSize</var>.</li></ol></li><li><ins>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>buffer</var>.</ins></li><li><ins>Set <var>O</var>.[[ByteOffset]] to <var>offset</var>.</ins></li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-dataview-objects-mods">
  <h1><span class="secnum">5</span> Modifications to DataView Objects</h1>

  <emu-clause id="sec-abstract-operations-for-dataview-objects-mods">
    <h1><span class="secnum">5.1</span> Modifications to Abstract Operations For DataView Objects</h1>

    <ins class="block">
    <emu-clause id="sec-getviewbytelength" aoid="GetViewByteLength">
      <h1><span class="secnum">5.1.1</span> GetViewByteLength ( <var>view</var>, <var>getBufferByteLength</var> )</h1>
      <p>The abstract operation GetViewByteLength takes arguments <var>view</var> and <var>getBufferByteLength</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_112"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>view</var>, [[DataView]]).</li><li>If <var>view</var>.[[ByteLength]] is not <emu-const>auto</emu-const>, then return <var>view</var>.[[ByteLength]].</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li>Return <var>getBufferByteLength</var>(<var>buffer</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-isviewoutofbounds" aoid="IsViewOutOfBounds">
      <h1><span class="secnum">5.1.2</span> IsViewOutOfBounds ( <var>view</var>, <var>getBufferByteLength</var> )</h1>
      <p>The abstract operation IsViewOutOfBounds takes arguments <var>view</var> and <var>getBufferByteLength</var>. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_113"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>view</var>, [[DataView]]).</li><li>Let <var>byteLength</var> be <emu-xref aoid="GetViewByteLength" id="_ref_114"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>).</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li>Let <var>bufferByteLength</var> be <var>getBufferByteLength</var>(<var>buffer</var>).</li><li>If <var>view</var>.[[ByteOffset]] + <var>byteLength</var> &gt; <var>bufferByteLength</var>, then return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-getviewvalue" aoid="GetViewValue">
      <h1><span class="secnum">5.1.3</span> GetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var> )</h1>
      <p>The abstract operation GetViewValue takes arguments <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, and <var>type</var>. It is used by functions on DataView instances to retrieve values from the view's buffer. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_115"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>view</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>view</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>getIndex</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_116"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>requestIndex</var>).</li><li>Set <var>isLittleEndian</var> to !&nbsp;<emu-xref aoid="ToBoolean" id="_ref_117"><a href="https://tc39.es/ecma262/#sec-toboolean">ToBoolean</a></emu-xref>(<var>isLittleEndian</var>).</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_118"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_119"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>view</var>'s backing buffer is a growable SharedArrayBuffer.</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_120"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>viewOffset</var> be <var>view</var>.[[ByteOffset]].</li><li>Let <var>viewSize</var> be <del><var>view</var>.[[ByteLength]]</del><ins><emu-xref aoid="GetViewByteLength" id="_ref_121"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>getIndex</var> + <var>elementSize</var> &gt; <var>viewSize</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>bufferIndex</var> be <var>getIndex</var> + <var>viewOffset</var>.</li><li>Return <emu-xref aoid="GetValueFromBuffer" id="_ref_122"><a href="https://tc39.es/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref>(<var>buffer</var>, <var>bufferIndex</var>, <var>type</var>, <emu-val>false</emu-val>, <emu-const>Unordered</emu-const>, <var>isLittleEndian</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-setviewvalue" aoid="SetViewValue">
      <h1><span class="secnum">5.1.4</span> SetViewValue ( <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, <var>value</var> )</h1>
      <p>The abstract operation SetViewValue takes arguments <var>view</var>, <var>requestIndex</var>, <var>isLittleEndian</var>, <var>type</var>, and <var>value</var>. It is used by functions on DataView instances to store values into the view's buffer. It performs the following steps when called:</p>
      <emu-alg><ol><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_123"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>view</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>view</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>getIndex</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_124"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>requestIndex</var>).</li><li>If !&nbsp;<emu-xref aoid="IsBigIntElementType" id="_ref_125"><a href="https://tc39.es/ecma262/#sec-isbigintelementtype">IsBigIntElementType</a></emu-xref>(<var>type</var>) is <emu-val>true</emu-val>, let <var>numberValue</var> be ?&nbsp;<emu-xref aoid="ToBigInt" id="_ref_126"><a href="https://tc39.es/ecma262/#sec-tobigint">ToBigInt</a></emu-xref>(<var>value</var>).</li><li>Otherwise, let <var>numberValue</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_127"><a href="https://tc39.es/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>value</var>).</li><li>Set <var>isLittleEndian</var> to !&nbsp;<emu-xref aoid="ToBoolean" id="_ref_128"><a href="https://tc39.es/ecma262/#sec-toboolean">ToBoolean</a></emu-xref>(<var>isLittleEndian</var>).</li><li>Let <var>buffer</var> be <var>view</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_129"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_130"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li><ins>NOTE: Bounds checking is not a synchronizing operation when <var>view</var>'s backing buffer is a growable SharedArrayBuffer.</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_131"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>viewOffset</var> be <var>view</var>.[[ByteOffset]].</li><li>Let <var>viewSize</var> be <del><var>view</var>.[[ByteLength]]</del><ins><emu-xref aoid="GetViewByteLength" id="_ref_132"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>view</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>getIndex</var> + <var>elementSize</var> &gt; <var>viewSize</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>bufferIndex</var> be <var>getIndex</var> + <var>viewOffset</var>.</li><li>Return <emu-xref aoid="SetValueInBuffer" id="_ref_133"><a href="https://tc39.es/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>(<var>buffer</var>, <var>bufferIndex</var>, <var>type</var>, <var>numberValue</var>, <emu-val>false</emu-val>, <emu-const>Unordered</emu-const>, <var>isLittleEndian</var>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-constructor-mods">
    <h1><span class="secnum">5.2</span> Modifications to the DataView Constructor</h1>

    <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
      <h1><span class="secnum">5.2.1</span> DataView ( <var>buffer</var> [ , <var>byteOffset</var> [ , <var>byteLength</var> ] ] )</h1>
      <p>When the <code>DataView</code> function is called with at least one argument <var>buffer</var>, the following steps are taken:</p>
      <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_134"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>buffer</var>, [[ArrayBufferData]]).</li><li>Let <var>offset</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_135"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>byteOffset</var>).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_136"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>bufferByteLength</var> be <del><var>buffer</var>.[[ArrayBufferByteLength]]</del><ins>ArrayBufferByteLengthGetter(<var>buffer</var>, <emu-const>SeqCst</emu-const>).</ins>.</li><li>If <var>offset</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li><ins>Let <var>bufferIsResizable</var> be <emu-xref aoid="IsResizableArrayBuffer" id="_ref_137"><a href="#sec-isresizablearraybuffer">IsResizableArrayBuffer</a></emu-xref>(<var>buffer</var>).</ins></li><li><ins>If <var>bufferIsResizable</var> is <emu-val>true</emu-val> and <var>byteLength</var> is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>Let <var>viewByteLength</var> be <emu-const>auto</emu-const>.</ins></li></ol></li><li><del>I</del><ins>Else i</ins>f <var>byteLength</var> is <emu-val>undefined</emu-val>, then<ol><li>Let <var>viewByteLength</var> be <var>bufferByteLength</var> - <var>offset</var>.</li></ol></li><li>Else,<ol><li>Let <var>viewByteLength</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_138"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>byteLength</var>).</li><li>If <var>offset</var> + <var>viewByteLength</var> &gt; <var>bufferByteLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li></ol></li><li>Let <var>O</var> be ?&nbsp;<emu-xref aoid="OrdinaryCreateFromConstructor" id="_ref_139"><a href="https://tc39.es/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(NewTarget, <emu-val>"%DataView.prototype%"</emu-val>, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_140"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Set <var>O</var>.[[ViewedArrayBuffer]] to <var>buffer</var>.</li><li>Set <var>O</var>.[[ByteLength]] to <var>viewByteLength</var>.</li><li>Set <var>O</var>.[[ByteOffset]] to <var>offset</var>.</li><li>Return <var>O</var>.</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-dataview-prototype-object-mods">
    <h1><span class="secnum">5.3</span> Modifications to Properties of the DataView Prototype Object</h1>

    <emu-clause id="sec-get-dataview.prototype.bytelength">
      <h1><span class="secnum">5.3.1</span> get DataView.prototype.byteLength</h1>
      <p><code>DataView.prototype.byteLength</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_141"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_142"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_143"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_144"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>size</var> be <del><var>O</var>.[[ByteLength]]</del><ins><emu-xref aoid="GetViewByteLength" id="_ref_145"><a href="#sec-getviewbytelength">GetViewByteLength</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>)</ins>.</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>size</var>).</li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-dataview.prototype.byteoffset">
      <h1><span class="secnum">5.3.2</span> get DataView.prototype.byteOffset</h1>
      <p><code>DataView.prototype.byteOffset</code> is an <emu-xref href="#sec-object-type"><a href="https://tc39.es/ecma262/#sec-object-type">accessor property</a></emu-xref> whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
      <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>Perform ?&nbsp;<emu-xref aoid="RequireInternalSlot" id="_ref_146"><a href="https://tc39.es/ecma262/#sec-requireinternalslot">RequireInternalSlot</a></emu-xref>(<var>O</var>, [[DataView]]).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>O</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>buffer</var> be <var>O</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_147"><a href="https://tc39.es/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_148"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>SeqCst</emu-const>).</ins></li><li><ins>If <emu-xref aoid="IsViewOutOfBounds" id="_ref_149"><a href="#sec-isviewoutofbounds">IsViewOutOfBounds</a></emu-xref>(<var>O</var>, <var>getBufferByteLength</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>Let <var>offset</var> be <var>O</var>.[[ByteOffset]].</li><li>Return <emu-xref href="#𝔽"><a href="https://tc39.es/ecma262/#𝔽">𝔽</a></emu-xref>(<var>offset</var>).</li></ol></emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations-for-atomics-mods">
  <h1><span class="secnum">6</span> Modifications to Abstract Operations for Atomics</h1>

  <emu-clause id="sec-validateatomicaccess" aoid="ValidateAtomicAccess">
    <h1><span class="secnum">6.1</span> ValidateAtomicAccess ( <var>typedArray</var>, <var>requestIndex</var> )</h1>
    <p>The abstract operation ValidateAtomicAccess takes arguments <var>typedArray</var> and <var>requestIndex</var>. It performs the following steps when called:</p>
    <emu-alg><ol><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>typedArray</var> is an Object that has a [[ViewedArrayBuffer]] internal slot.</li><li><ins>Let <var>getBufferByteLength</var> be !&nbsp;<emu-xref aoid="MakeIdempotentArrayBufferByteLengthGetter" id="_ref_150"><a href="#sec-makeidempotentarraybufferbytelengthgetter">MakeIdempotentArrayBufferByteLengthGetter</a></emu-xref>(<emu-const>Unordered</emu-const>).</ins></li><li>Let <var>length</var> be <del><var>typedArray</var>.[[ArrayLength]]</del><ins><emu-xref aoid="IntegerIndexedObjectLength" id="_ref_151"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>(<var>typedArray</var>)</ins>.</li><li>Let <var>accessIndex</var> be ?&nbsp;<emu-xref aoid="ToIndex" id="_ref_152"><a href="https://tc39.es/ecma262/#sec-toindex">ToIndex</a></emu-xref>(<var>requestIndex</var>).</li><li><emu-xref href="#assert"><a href="https://tc39.es/ecma262/#assert">Assert</a></emu-xref>: <var>accessIndex</var> ≥ 0.</li><li>If <var>accessIndex</var> ≥ <var>length</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"><a href="https://tc39.es/ecma262/#table-the-typedarray-constructors">Table 63</a></emu-xref> for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Return (<var>accessIndex</var> × <var>elementSize</var>) + <var>offset</var>.</li></ol></emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-maxbytelength-guidelines">
  <h1><span class="secnum">7</span> Resizable ArrayBuffer and growable SharedArrayBuffer Guidelines</h1>
  <emu-note><span class="note">Note 1</span><div class="note-contents">
    <p>The following are guidelines for ECMAScript programmers working with resizable ArrayBuffer and growable SharedArrayBuffer.</p>
    <p>We recommend that programs be tested in their deployment environments where possible. The amount of available physical memory differ greatly between hardware devices. Similarly, virtual memory subsystems also differ greatly between hardware devices as well as operating systems. An application that runs without out-of-memory errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile web browser.</p>
    <p>When choosing a value for <var>requestedMaxByteLength</var> parameters for resizable ArrayBuffer and growable SharedArrayBuffer, we recommend that the smallest possible size for the application be chosen. We recommend that <var>requestedMaxByteLength</var> does not exceed 1073741824, or 1GiB.</p>
    <p>Please note that successfully constructing a ResizableArrayBuffer or a growable SharedArrayBuffer for a particular maximum size does not guarantee that future resizes and grows will succeed.</p>
  </div></emu-note>

  <emu-note><span class="note">Note 2</span><div class="note-contents">
    <p>The following are guidelines for ECMAScript implementers implementing resizable ArrayBuffer.</p>
    <p>Resizable ArrayBuffer can be implemented as copying upon resize, as in-place growth via reserving virtual memory up front, or as a combination of both for different values of the <emu-xref href="#constructor"><a href="https://tc39.es/ecma262/#constructor">constructor</a></emu-xref>'s <var>requestedMaxByteLength</var> parameter.</p>
    <p>If a host is multi-tenanted (i.e. it runs many JavaScript applications simultaneously), such as a web browser, and its implementations choose to implement in-place growth by reserving virtual memory, we recommend that both 32-bit and 64-bit implementations throw for values of <var>requestedMaxByteLength</var> ≥ 1GiB to 1.5GiB. This is to reduce the likelihood a single application can exhaust the virtual memory address space and to reduce interoperability risks.</p>
    <p>If a host does not have virtual memory, such as those running on embedded devices, or if a host only implements resizing by copying, it may ignore the <var>requestedMaxByteLength</var> parameter. However, we recommend a <emu-val>RangeError</emu-val> be thrown if a memory block of the requested size can never be allocated. For example, if the requested size is greater than the maximium amount of usable memory on the device.</p>
  </div></emu-note>

  <emu-note><span class="note">Note 3</span><div class="note-contents">
    <p>The following are guidelines for ECMAScript implementers implementing growable SharedArrayBuffer.</p>
    <p>We recommend growable SharedArrayBuffer be implemented as in-place growth via reserving virtual memory up front.</p>
    <p>Because grow operations can be concurrent with memory accesses on a growable SharedArrayBuffer, the constraints of the <emu-xref href="#sec-memory-model"><a href="https://tc39.es/ecma262/#sec-memory-model">memory model</a></emu-xref> require that even unordered accesses do not "tear" (bits of their values will not be mixed). In practice, this means the underlying data block of a growable SharedArrayBuffer cannot be grown by being copied without stopping the world. We do not recommend stopping the world as an implementation strategy because it introduces a serialization point and is slow.</p>
    <p>If a host does not have virtual memory, such as those running on embedded devices, we recommend ignoring the <var>requestedMaxByteLength</var> parameter, throwing on calling SharedArrayBuffer.prototype.grow, and communicating to users that growable SharedArrayBuffers cannot be grown.</p>
  </div></emu-note>
</emu-clause>

<emu-clause id="omitted-for-brevity">
  <h1><span class="secnum">8</span> Mechanical Changes Omitted for Brevity</h1>
  <ul>
    <li><p>Uses of [[ArrayLength]] on <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">Integer</a></emu-xref>-Indexed exotic objects are replaced with calls to <emu-xref aoid="IntegerIndexedObjectLength" id="_ref_153"><a href="#sec-integerindexedobjectlength">IntegerIndexedObjectLength</a></emu-xref>.</p></li>
    <li><p>Uses of [[ByteLength]] on <emu-xref href="#integer"><a href="https://tc39.es/ecma262/#integer">Integer</a></emu-xref>-Indexed exotic objects are replaced with calls to IntegerIndexedByteLength.</p></li>
    <li><p>Uses of [[ArrayBufferByteLength]] on buffer objects that may be growable SharedArrayBuffers are replaced with calls to <emu-xref aoid="ArrayBufferByteLength" id="_ref_154"><a href="#sec-arraybufferlength">ArrayBufferByteLength</a></emu-xref>.</p></li>
  </ul>
</emu-clause>
</div></body>